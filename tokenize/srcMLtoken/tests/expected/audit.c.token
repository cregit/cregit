-:-	begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
-:-	begin_comment
1:1	comment|/* audit.c -- Auditing support  * Gateway between the kernel (e.g., selinux) and the user-space audit daemon.  * System-call specific features have moved to auditsc.c  *  * Copyright 2003-2007 Red Hat Inc., Durham, North Carolina.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA  *  * Written by Rickard E. (Rik) Faith<faith@redhat.com>  *  * Goals: 1) Integrate fully with Security Modules.  *	  2) Minimal run-time overhead:  *	     a) Minimal when syscall auditing is disabled (audit_enable=0).  *	     b) Small when syscall auditing is enabled and no audit record  *		is generated (defer as much work as possible to record  *		generation time):  *		i) context is allocated,  *		ii) names from getname are stored without a copy, and  *		iii) inode information stored from path_lookup.  *	  3) Ability to disable syscall auditing at boot time (audit=0).  *	  4) Usable by other parts of the kernel (if audit_log* is called,  *	     then a syscall record will be generated automatically for the  *	     current syscall).  *	  5) Netlink interface to user-space.  *	  6) Support low-overhead kernel-based filtering to minimize the  *	     information that must be passed to user-space.  *  * Example user-space utilities: http://people.redhat.com/sgrubb/audit/  */
-:-	end_comment
-:-	begin_define
44:1	define|#
44:2	directive|define
44:9	name|pr_fmt
44:15	parameter_list|(
44:16	name|fmt
44:19	parameter_list|)
44:21	value|KBUILD_MODNAME ": " fmt
-:-	end_define
-:-	begin_include
46:1	include|#
46:2	directive|include
46:10	file|<linux/file.h>
-:-	end_include
-:-	begin_include
47:1	include|#
47:2	directive|include
47:10	file|<linux/init.h>
-:-	end_include
-:-	begin_include
48:1	include|#
48:2	directive|include
48:10	file|<linux/types.h>
-:-	end_include
-:-	begin_include
49:1	include|#
49:2	directive|include
49:10	file|<linux/atomic.h>
-:-	end_include
-:-	begin_include
50:1	include|#
50:2	directive|include
50:10	file|<linux/mm.h>
-:-	end_include
-:-	begin_include
51:1	include|#
51:2	directive|include
51:10	file|<linux/export.h>
-:-	end_include
-:-	begin_include
52:1	include|#
52:2	directive|include
52:10	file|<linux/slab.h>
-:-	end_include
-:-	begin_include
53:1	include|#
53:2	directive|include
53:10	file|<linux/err.h>
-:-	end_include
-:-	begin_include
54:1	include|#
54:2	directive|include
54:10	file|<linux/kthread.h>
-:-	end_include
-:-	begin_include
55:1	include|#
55:2	directive|include
55:10	file|<linux/kernel.h>
-:-	end_include
-:-	begin_include
56:1	include|#
56:2	directive|include
56:10	file|<linux/syscalls.h>
-:-	end_include
-:-	begin_include
57:1	include|#
57:2	directive|include
57:10	file|<linux/spinlock.h>
-:-	end_include
-:-	begin_include
58:1	include|#
58:2	directive|include
58:10	file|<linux/rcupdate.h>
-:-	end_include
-:-	begin_include
59:1	include|#
59:2	directive|include
59:10	file|<linux/mutex.h>
-:-	end_include
-:-	begin_include
60:1	include|#
60:2	directive|include
60:10	file|<linux/gfp.h>
-:-	end_include
-:-	begin_include
62:1	include|#
62:2	directive|include
62:10	file|<linux/audit.h>
-:-	end_include
-:-	begin_include
64:1	include|#
64:2	directive|include
64:10	file|<net/sock.h>
-:-	end_include
-:-	begin_include
65:1	include|#
65:2	directive|include
65:10	file|<net/netlink.h>
-:-	end_include
-:-	begin_include
66:1	include|#
66:2	directive|include
66:10	file|<linux/skbuff.h>
-:-	end_include
-:-	begin_ifdef
67:1	ifdef|#
67:2	directive|ifdef
67:8	name|CONFIG_SECURITY
-:-	end_ifdef
-:-	begin_include
68:1	include|#
68:2	directive|include
68:10	file|<linux/security.h>
-:-	end_include
-:-	begin_endif
69:1	endif|#
69:2	directive|endif
-:-	end_endif
-:-	begin_include
70:1	include|#
70:2	directive|include
70:10	file|<linux/freezer.h>
-:-	end_include
-:-	begin_include
71:1	include|#
71:2	directive|include
71:10	file|<linux/pid_namespace.h>
-:-	end_include
-:-	begin_include
72:1	include|#
72:2	directive|include
72:10	file|<net/netns/generic.h>
-:-	end_include
-:-	begin_include
74:1	include|#
74:2	directive|include
74:10	file|"audit.h"
-:-	end_include
-:-	begin_comment
76:1	comment|/* No auditing will take place until audit_initialized == AUDIT_INITIALIZED.  * (Initialization happens after skb_init is called.) */
-:-	end_comment
-:-	begin_define
78:1	define|#
78:2	directive|define
78:9	name|AUDIT_DISABLED
78:33	value|-1
-:-	end_define
-:-	begin_define
79:1	define|#
79:2	directive|define
79:9	name|AUDIT_UNINITIALIZED
79:33	value|0
-:-	end_define
-:-	begin_define
80:1	define|#
80:2	directive|define
80:9	name|AUDIT_INITIALIZED
80:33	value|1
-:-	end_define
-:-	begin_decl_stmt
81:1	specifier|static
81:8	name|int
81:17	name|audit_initialized
81:34	decl_stmt|;
-:-	end_decl_stmt
-:-	begin_define
83:1	define|#
83:2	directive|define
83:9	name|AUDIT_OFF
83:25	value|0
-:-	end_define
-:-	begin_define
84:1	define|#
84:2	directive|define
84:9	name|AUDIT_ON
84:25	value|1
-:-	end_define
-:-	begin_define
85:1	define|#
85:2	directive|define
85:9	name|AUDIT_LOCKED
85:25	value|2
-:-	end_define
-:-	begin_decl_stmt
86:1	name|u32
86:17	name|audit_enabled
86:30	decl_stmt|;
-:-	end_decl_stmt
-:-	begin_decl_stmt
87:1	name|u32
87:17	name|audit_ever_enabled
87:35	decl_stmt|;
-:-	end_decl_stmt
-:-	begin_expr_stmt
89:1	name|EXPORT_SYMBOL_GPL
89:18	argument_list|(
89:19	name|audit_enabled
89:32	argument_list|)
89:33	expr_stmt|;
-:-	end_expr_stmt
-:-	begin_comment
91:1	comment|/* Default state when kernel boots without any parameters. */
-:-	end_comment
-:-	begin_decl_stmt
92:1	specifier|static
92:8	name|u32
92:17	name|audit_default
92:30	decl_stmt|;
-:-	end_decl_stmt
-:-	begin_comment
94:1	comment|/* If auditing cannot proceed, audit_failure selects what happens. */
-:-	end_comment
-:-	begin_decl_stmt
95:1	specifier|static
95:8	name|u32
95:17	name|audit_failure
95:31	init|=
95:33	name|AUDIT_FAIL_PRINTK
95:50	decl_stmt|;
-:-	end_decl_stmt
-:-	begin_comment
97:1	comment|/* private audit network namespace index */
-:-	end_comment
-:-	begin_decl_stmt
98:1	specifier|static
98:8	name|unsigned
98:17	name|int
98:21	name|audit_net_id
98:33	decl_stmt|;
-:-	end_decl_stmt
-:-	begin_comment
100:1	comment|/**  * struct audit_net - audit private network namespace data  * @sk: communication socket  */
-:-	end_comment
-:-	begin_struct
104:1	struct|struct
104:8	name|audit_net
104:18	block|{
105:9	name|struct
105:16	name|sock
105:21	modifier|*
105:22	name|sk
105:24	decl_stmt|;
105:25	block|}
106:2	struct|;
-:-	end_struct
-:-	begin_comment
108:1	comment|/**  * struct auditd_connection - kernel/auditd connection state  * @pid: auditd PID  * @portid: netlink portid  * @net: the associated network namespace  * @lock: spinlock to protect write access  *  * Description:  * This struct is RCU protected; you must either hold the RCU lock for reading  * or the included spinlock for writing.  */
-:-	end_comment
-:-	begin_struct
119:1	specifier|static
119:7	struct|struct
119:15	name|auditd_connection
119:33	block|{
120:9	name|int
120:13	name|pid
120:16	decl_stmt|;
121:9	name|u32
121:13	name|portid
121:19	decl_stmt|;
122:9	name|struct
122:16	name|net
122:20	modifier|*
122:21	name|net
122:24	decl_stmt|;
123:9	name|spinlock_t
123:20	name|lock
123:24	decl_stmt|;
123:25	block|}
124:3	name|auditd_conn
124:14	struct|;
-:-	end_struct
-:-	begin_comment
126:1	comment|/* If audit_rate_limit is non-zero, limit the rate of sending audit records  * to that number per second.  This prevents DoS attacks, but results in  * audit records being dropped. */
-:-	end_comment
-:-	begin_decl_stmt
129:1	specifier|static
129:8	name|u32
129:17	name|audit_rate_limit
129:33	decl_stmt|;
-:-	end_decl_stmt
-:-	begin_comment
131:1	comment|/* Number of outstanding audit_buffers allowed.  * When set to zero, this means unlimited. */
-:-	end_comment
-:-	begin_decl_stmt
133:1	specifier|static
133:8	name|u32
133:17	name|audit_backlog_limit
133:37	init|=
133:39	literal|64
133:41	decl_stmt|;
-:-	end_decl_stmt
-:-	begin_define
134:1	define|#
134:2	directive|define
134:9	name|AUDIT_BACKLOG_WAIT_TIME
134:33	value|(60 * HZ)
-:-	end_define
-:-	begin_decl_stmt
135:1	specifier|static
135:8	name|u32
135:17	name|audit_backlog_wait_time
135:41	init|=
135:43	name|AUDIT_BACKLOG_WAIT_TIME
135:66	decl_stmt|;
-:-	end_decl_stmt
-:-	begin_comment
137:1	comment|/* The identity of the user shutting down the audit system. */
-:-	end_comment
-:-	begin_decl_stmt
138:1	name|kuid_t
138:17	name|audit_sig_uid
138:31	init|=
138:33	name|INVALID_UID
138:44	decl_stmt|;
-:-	end_decl_stmt
-:-	begin_decl_stmt
139:1	name|pid_t
139:17	name|audit_sig_pid
139:31	init|=
139:33	operator|-
139:34	literal|1
139:35	decl_stmt|;
-:-	end_decl_stmt
-:-	begin_decl_stmt
140:1	name|u32
140:17	name|audit_sig_sid
140:31	init|=
140:33	literal|0
140:34	decl_stmt|;
-:-	end_decl_stmt
-:-	begin_comment
142:1	comment|/* Records can be lost in several ways:    0) [suppressed in audit_alloc]    1) out of memory in audit_log_start [kmalloc of struct audit_buffer]    2) out of memory in audit_log_move [alloc_skb]    3) suppressed due to audit_rate_limit    4) suppressed due to audit_backlog_limit */
-:-	end_comment
-:-	begin_decl_stmt
149:1	specifier|static
149:8	name|atomic_t
149:17	name|audit_lost
149:28	init|=
149:30	name|ATOMIC_INIT
149:41	argument_list|(
149:42	literal|0
149:43	argument_list|)
149:44	decl_stmt|;
-:-	end_decl_stmt
-:-	begin_comment
151:1	comment|/* Hash for inode-based rules */
-:-	end_comment
-:-	begin_decl_stmt
152:1	name|struct
152:8	name|list_head
152:18	name|audit_inode_hash
152:34	index|[
152:35	name|AUDIT_INODE_BUCKETS
152:54	index|]
152:55	decl_stmt|;
-:-	end_decl_stmt
-:-	begin_comment
154:1	comment|/* The audit_freelist is a list of pre-allocated audit buffers (if more  * than AUDIT_MAXFREE are in use, the audit buffer is freed instead of  * being placed on the freelist). */
-:-	end_comment
-:-	begin_expr_stmt
157:1	specifier|static
157:8	name|DEFINE_SPINLOCK
157:23	argument_list|(
157:24	name|audit_freelist_lock
157:43	argument_list|)
157:44	expr_stmt|;
-:-	end_expr_stmt
-:-	begin_decl_stmt
158:1	specifier|static
158:8	name|int
158:20	name|audit_freelist_count
158:40	decl_stmt|;
-:-	end_decl_stmt
-:-	begin_expr_stmt
159:1	specifier|static
159:8	name|LIST_HEAD
159:17	argument_list|(
159:18	name|audit_freelist
159:32	argument_list|)
159:33	expr_stmt|;
-:-	end_expr_stmt
-:-	begin_comment
161:1	comment|/* queue msgs to send via kauditd_task */
-:-	end_comment
-:-	begin_decl_stmt
162:1	specifier|static
162:8	name|struct
162:15	name|sk_buff_head
162:28	name|audit_queue
162:39	decl_stmt|;
-:-	end_decl_stmt
-:-	begin_comment
163:1	comment|/* queue msgs due to temporary unicast send problems */
-:-	end_comment
-:-	begin_decl_stmt
164:1	specifier|static
164:8	name|struct
164:15	name|sk_buff_head
164:28	name|audit_retry_queue
164:45	decl_stmt|;
-:-	end_decl_stmt
-:-	begin_comment
165:1	comment|/* queue msgs waiting for new auditd connection */
-:-	end_comment
-:-	begin_decl_stmt
166:1	specifier|static
166:8	name|struct
166:15	name|sk_buff_head
166:28	name|audit_hold_queue
166:44	decl_stmt|;
-:-	end_decl_stmt
-:-	begin_comment
168:1	comment|/* queue servicing thread */
-:-	end_comment
-:-	begin_decl_stmt
169:1	specifier|static
169:8	name|struct
169:15	name|task_struct
169:27	modifier|*
169:28	name|kauditd_task
169:40	decl_stmt|;
-:-	end_decl_stmt
-:-	begin_expr_stmt
170:1	specifier|static
170:8	name|DECLARE_WAIT_QUEUE_HEAD
170:31	argument_list|(
170:32	name|kauditd_wait
170:44	argument_list|)
170:45	expr_stmt|;
-:-	end_expr_stmt
-:-	begin_comment
172:1	comment|/* waitqueue for callers who are blocked on the audit backlog */
-:-	end_comment
-:-	begin_expr_stmt
173:1	specifier|static
173:8	name|DECLARE_WAIT_QUEUE_HEAD
173:31	argument_list|(
173:32	name|audit_backlog_wait
173:50	argument_list|)
173:51	expr_stmt|;
-:-	end_expr_stmt
-:-	begin_decl_stmt
175:1	specifier|static
175:8	name|struct
175:15	name|audit_features
175:30	name|af
175:33	init|=
175:35	block|{
175:36	operator|.
175:37	name|vers
175:42	operator|=
175:44	name|AUDIT_FEATURE_VERSION
175:65	block|,
176:36	operator|.
176:37	name|mask
176:42	operator|=
176:44	operator|-
176:45	literal|1
176:46	block|,
177:36	operator|.
177:37	name|features
177:46	operator|=
177:48	literal|0
177:49	block|,
178:36	operator|.
178:37	name|lock
178:42	operator|=
178:44	literal|0
178:45	block|,}
178:47	decl_stmt|;
-:-	end_decl_stmt
-:-	begin_decl_stmt
180:1	specifier|static
180:8	name|char
180:13	modifier|*
180:14	name|audit_feature_names
180:33	index|[
180:34	literal|2
180:35	index|]
180:37	init|=
180:39	block|{
181:9	literal|"only_unset_loginuid"
181:30	block|,
182:9	literal|"loginuid_immutable"
182:29	block|, }
183:2	decl_stmt|;
-:-	end_decl_stmt
-:-	begin_comment
186:1	comment|/* Serialize requests from userspace. */
-:-	end_comment
-:-	begin_expr_stmt
187:1	name|DEFINE_MUTEX
187:13	argument_list|(
187:14	name|audit_cmd_mutex
187:29	argument_list|)
187:30	expr_stmt|;
-:-	end_expr_stmt
-:-	begin_comment
189:1	comment|/* AUDIT_BUFSIZ is the size of the temporary buffer used for formatting  * audit records.  Since printk uses a 1024 byte buffer, this buffer  * should be at least that large. */
-:-	end_comment
-:-	begin_define
192:1	define|#
192:2	directive|define
192:9	name|AUDIT_BUFSIZ
192:22	value|1024
-:-	end_define
-:-	begin_comment
194:1	comment|/* AUDIT_MAXFREE is the number of empty audit_buffers we keep on the  * audit_freelist.  Doing so eliminates many kmalloc/kfree calls. */
-:-	end_comment
-:-	begin_define
196:1	define|#
196:2	directive|define
196:9	name|AUDIT_MAXFREE
196:24	value|(2*NR_CPUS)
-:-	end_define
-:-	begin_comment
198:1	comment|/* The audit_buffer is used when formatting an audit record.  The caller  * locks briefly to get the record off the freelist or to allocate the  * buffer, and locks briefly to send the buffer to the netlink layer or  * to place it on a transmit queue.  Multiple audit_buffers can be in  * use simultaneously. */
-:-	end_comment
-:-	begin_struct
203:1	struct|struct
203:8	name|audit_buffer
203:21	block|{
204:9	name|struct
204:16	name|list_head
204:30	name|list
204:34	decl_stmt|;
205:9	name|struct
205:16	name|sk_buff
205:30	modifier|*
205:31	name|skb
205:34	decl_stmt|;
205:41	comment|/* formatted skb ready to send */
206:9	name|struct
206:16	name|audit_context
206:30	modifier|*
206:31	name|ctx
206:34	decl_stmt|;
206:41	comment|/* NULL or associated context */
207:9	name|gfp_t
207:30	name|gfp_mask
207:38	decl_stmt|;
207:39	block|}
208:2	struct|;
-:-	end_struct
-:-	begin_struct
210:1	struct|struct
210:8	name|audit_reply
210:20	block|{
211:9	name|__u32
211:15	name|portid
211:21	decl_stmt|;
212:9	name|struct
212:16	name|net
212:20	modifier|*
212:21	name|net
212:24	decl_stmt|;
213:9	name|struct
213:16	name|sk_buff
213:24	modifier|*
213:25	name|skb
213:28	decl_stmt|;
213:29	block|}
214:2	struct|;
-:-	end_struct
-:-	begin_comment
216:1	comment|/**  * auditd_test_task - Check to see if a given task is an audit daemon  * @task: the task to check  *  * Description:  * Return 1 if the task is a registered audit daemon, 0 otherwise.  */
-:-	end_comment
-:-	begin_function
223:1	name|int
223:5	name|auditd_test_task
223:21	parameter_list|(
223:22	specifier|const
223:28	name|struct
223:35	name|task_struct
223:47	modifier|*
223:48	name|task
223:52	parameter_list|)
224:1	block|{
225:9	name|int
225:13	name|rc
225:15	decl_stmt|;
227:9	name|rcu_read_lock
227:22	argument_list|()
227:24	expr_stmt|;
228:9	name|rc
228:12	operator|=
228:14	operator|(
228:15	name|auditd_conn
228:26	operator|.
228:27	name|pid
228:31	operator|&&
228:34	name|task
228:38	operator|->
228:40	name|tgid
228:45	operator|==
228:48	name|auditd_conn
228:59	operator|.
228:60	name|pid
228:63	condition|?
228:66	literal|1
228:68	else|:
228:70	literal|0
228:71	operator|)
228:72	expr_stmt|;
229:9	name|rcu_read_unlock
229:24	argument_list|()
229:26	expr_stmt|;
231:9	return|return
231:16	name|rc
231:18	return|;
231:19	block|}
-:-	end_function
-:-	begin_comment
234:1	comment|/**  * audit_get_sk - Return the audit socket for the given network namespace  * @net: the destination network namespace  *  * Description:  * Returns the sock pointer if valid, NULL otherwise.  The caller must ensure  * that a reference is held for the network namespace while the sock is in use.  */
-:-	end_comment
-:-	begin_function
242:1	specifier|static
242:8	name|struct
242:15	name|sock
242:20	modifier|*
242:21	name|audit_get_sk
242:33	parameter_list|(
242:34	specifier|const
242:40	name|struct
242:47	name|net
242:51	modifier|*
242:52	name|net
242:55	parameter_list|)
243:1	block|{
244:9	name|struct
244:16	name|audit_net
244:26	modifier|*
244:27	name|aunet
244:32	decl_stmt|;
246:9	if|if
246:12	condition|(
246:13	operator|!
246:14	name|net
246:17	condition|)
247:17	return|return
247:24	name|NULL
247:28	return|;
249:9	name|aunet
249:15	operator|=
249:17	name|net_generic
249:28	argument_list|(
249:29	name|net
249:32	argument_list|,
249:34	name|audit_net_id
249:46	argument_list|)
249:47	expr_stmt|;
250:9	return|return
250:16	name|aunet
250:21	operator|->
250:23	name|sk
250:25	return|;
250:26	block|}
-:-	end_function
-:-	begin_function
253:1	specifier|static
253:8	name|void
253:13	name|audit_set_portid
253:29	parameter_list|(
253:30	name|struct
253:37	name|audit_buffer
253:50	modifier|*
253:51	name|ab
253:53	parameter_list|,
253:55	name|__u32
253:61	name|portid
253:67	parameter_list|)
254:1	block|{
255:9	if|if
255:12	condition|(
255:13	name|ab
255:15	condition|)
255:17	block|{
256:17	name|struct
256:24	name|nlmsghdr
256:33	modifier|*
256:34	name|nlh
256:38	init|=
256:40	name|nlmsg_hdr
256:49	argument_list|(
256:50	name|ab
256:52	operator|->
256:54	name|skb
256:57	argument_list|)
256:58	decl_stmt|;
257:17	name|nlh
257:20	operator|->
257:22	name|nlmsg_pid
257:32	operator|=
257:34	name|portid
257:40	expr_stmt|;
257:41	block|}
258:10	block|}
-:-	end_function
-:-	begin_function
261:1	name|void
261:6	name|audit_panic
261:17	parameter_list|(
261:18	specifier|const
261:24	name|char
261:29	modifier|*
261:30	name|message
261:37	parameter_list|)
262:1	block|{
263:9	switch|switch
263:16	condition|(
263:17	name|audit_failure
263:30	condition|)
263:32	block|{
264:9	case|case
264:14	name|AUDIT_FAIL_SILENT
264:31	case|:
265:17	break|break;
266:9	case|case
266:14	name|AUDIT_FAIL_PRINTK
266:31	case|:
267:17	if|if
267:20	condition|(
267:21	name|printk_ratelimit
267:37	argument_list|()
267:39	condition|)
268:25	name|pr_err
268:31	argument_list|(
268:32	literal|"%s\n"
268:38	argument_list|,
268:40	name|message
268:47	argument_list|)
268:48	expr_stmt|;
269:17	break|break;
270:9	case|case
270:14	name|AUDIT_FAIL_PANIC
270:30	case|:
271:17	name|panic
271:22	argument_list|(
271:23	literal|"audit: %s\n"
271:36	argument_list|,
271:38	name|message
271:45	argument_list|)
271:46	expr_stmt|;
272:17	break|break;
272:23	block|}
273:10	block|}
-:-	end_function
-:-	begin_function
276:1	specifier|static
276:8	specifier|inline
276:15	name|int
276:19	name|audit_rate_check
276:35	parameter_list|(
276:36	name|void
276:40	parameter_list|)
277:1	block|{
278:9	specifier|static
278:16	name|unsigned
278:25	name|long
278:33	name|last_check
278:44	init|=
278:46	literal|0
278:47	decl_stmt|;
279:9	specifier|static
279:16	name|int
279:33	name|messages
279:44	init|=
279:46	literal|0
279:47	decl_stmt|;
280:9	specifier|static
280:16	name|DEFINE_SPINLOCK
280:31	argument_list|(
280:32	name|lock
280:36	argument_list|)
280:37	expr_stmt|;
281:9	name|unsigned
281:18	name|long
281:33	name|flags
281:38	decl_stmt|;
282:9	name|unsigned
282:18	name|long
282:33	name|now
282:36	decl_stmt|;
283:9	name|unsigned
283:18	name|long
283:33	name|elapsed
283:40	decl_stmt|;
284:9	name|int
284:33	name|retval
284:44	init|=
284:46	literal|0
284:47	decl_stmt|;
286:9	if|if
286:12	condition|(
286:13	operator|!
286:14	name|audit_rate_limit
286:30	condition|)
286:32	return|return
286:39	literal|1
286:40	return|;
288:9	name|spin_lock_irqsave
288:26	argument_list|(
288:27	operator|&
288:28	name|lock
288:32	argument_list|,
288:34	name|flags
288:39	argument_list|)
288:40	expr_stmt|;
289:9	if|if
289:12	condition|(
289:13	operator|++
289:15	name|messages
289:24	operator|<
289:26	name|audit_rate_limit
289:42	condition|)
289:44	block|{
290:17	name|retval
290:24	operator|=
290:26	literal|1
290:27	expr_stmt|;
290:28	block|}
291:11	else|else
291:16	block|{
292:17	name|now
292:25	operator|=
292:27	name|jiffies
292:34	expr_stmt|;
293:17	name|elapsed
293:25	operator|=
293:27	name|now
293:31	operator|-
293:33	name|last_check
293:43	expr_stmt|;
294:17	if|if
294:20	condition|(
294:21	name|elapsed
294:29	operator|>
294:31	name|HZ
294:33	condition|)
294:35	block|{
295:25	name|last_check
295:36	operator|=
295:38	name|now
295:41	expr_stmt|;
296:25	name|messages
296:36	operator|=
296:38	literal|0
296:39	expr_stmt|;
297:25	name|retval
297:36	operator|=
297:38	literal|1
297:39	expr_stmt|;
297:40	block|}
298:18	block|}
300:9	name|spin_unlock_irqrestore
300:31	argument_list|(
300:32	operator|&
300:33	name|lock
300:37	argument_list|,
300:39	name|flags
300:44	argument_list|)
300:45	expr_stmt|;
302:9	return|return
302:16	name|retval
302:22	return|;
302:23	block|}
-:-	end_function
-:-	begin_comment
305:1	comment|/**  * audit_log_lost - conditionally log lost audit message event  * @message: the message stating reason for lost audit message  *  * Emit at least 1 message per second, even if audit_rate_check is  * throttling.  * Always increment the lost messages counter. */
-:-	end_comment
-:-	begin_function
313:1	name|void
313:6	name|audit_log_lost
313:20	parameter_list|(
313:21	specifier|const
313:27	name|char
313:32	modifier|*
313:33	name|message
313:40	parameter_list|)
314:1	block|{
315:9	specifier|static
315:16	name|unsigned
315:25	name|long
315:33	name|last_msg
315:42	init|=
315:44	literal|0
315:45	decl_stmt|;
316:9	specifier|static
316:16	name|DEFINE_SPINLOCK
316:31	argument_list|(
316:32	name|lock
316:36	argument_list|)
316:37	expr_stmt|;
317:9	name|unsigned
317:18	name|long
317:33	name|flags
317:38	decl_stmt|;
318:9	name|unsigned
318:18	name|long
318:33	name|now
318:36	decl_stmt|;
319:9	name|int
319:33	name|print
319:38	decl_stmt|;
321:9	name|atomic_inc
321:19	argument_list|(
321:20	operator|&
321:21	name|audit_lost
321:31	argument_list|)
321:32	expr_stmt|;
323:9	name|print
323:15	operator|=
323:17	operator|(
323:18	name|audit_failure
323:32	operator|==
323:35	name|AUDIT_FAIL_PANIC
323:52	operator|||
323:55	operator|!
323:56	name|audit_rate_limit
323:72	operator|)
323:73	expr_stmt|;
325:9	if|if
325:12	condition|(
325:13	operator|!
325:14	name|print
325:19	condition|)
325:21	block|{
326:17	name|spin_lock_irqsave
326:34	argument_list|(
326:35	operator|&
326:36	name|lock
326:40	argument_list|,
326:42	name|flags
326:47	argument_list|)
326:48	expr_stmt|;
327:17	name|now
327:21	operator|=
327:23	name|jiffies
327:30	expr_stmt|;
328:17	if|if
328:20	condition|(
328:21	name|now
328:25	operator|-
328:27	name|last_msg
328:36	operator|>
328:38	name|HZ
328:40	condition|)
328:42	block|{
329:25	name|print
329:31	operator|=
329:33	literal|1
329:34	expr_stmt|;
330:25	name|last_msg
330:34	operator|=
330:36	name|now
330:39	expr_stmt|;
330:40	block|}
332:17	name|spin_unlock_irqrestore
332:39	argument_list|(
332:40	operator|&
332:41	name|lock
332:45	argument_list|,
332:47	name|flags
332:52	argument_list|)
332:53	expr_stmt|;
332:54	block|}
335:9	if|if
335:12	condition|(
335:13	name|print
335:18	condition|)
335:20	block|{
336:17	if|if
336:20	condition|(
336:21	name|printk_ratelimit
336:37	argument_list|()
336:39	condition|)
337:25	name|pr_warn
337:32	argument_list|(
337:33	literal|"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\n"
337:93	argument_list|,
338:33	name|atomic_read
338:44	argument_list|(
338:45	operator|&
338:46	name|audit_lost
338:56	argument_list|)
338:57	argument_list|,
339:33	name|audit_rate_limit
339:49	argument_list|,
340:33	name|audit_backlog_limit
340:52	argument_list|)
340:53	expr_stmt|;
341:17	name|audit_panic
341:28	argument_list|(
341:29	name|message
341:36	argument_list|)
341:37	expr_stmt|;
341:38	block|}
342:10	block|}
-:-	end_function
-:-	begin_function
345:1	specifier|static
345:8	name|int
345:12	name|audit_log_config_change
345:35	parameter_list|(
345:36	name|char
345:41	modifier|*
345:42	name|function_name
345:55	parameter_list|,
345:57	name|u32
345:61	name|new
345:64	parameter_list|,
345:66	name|u32
345:70	name|old
345:73	parameter_list|,
346:36	name|int
346:40	name|allow_changes
346:53	parameter_list|)
347:1	block|{
348:9	name|struct
348:16	name|audit_buffer
348:29	modifier|*
348:30	name|ab
348:32	decl_stmt|;
349:9	name|int
349:13	name|rc
349:16	init|=
349:18	literal|0
349:19	decl_stmt|;
351:9	name|ab
351:12	operator|=
351:14	name|audit_log_start
351:29	argument_list|(
351:30	name|NULL
351:34	argument_list|,
351:36	name|GFP_KERNEL
351:46	argument_list|,
351:48	name|AUDIT_CONFIG_CHANGE
351:67	argument_list|)
351:68	expr_stmt|;
352:9	if|if
352:12	condition|(
352:13	name|unlikely
352:21	argument_list|(
352:22	operator|!
352:23	name|ab
352:25	argument_list|)
352:26	condition|)
353:17	return|return
353:24	name|rc
353:26	return|;
354:9	name|audit_log_format
354:25	argument_list|(
354:26	name|ab
354:28	argument_list|,
354:30	literal|"%s=%u old=%u"
354:44	argument_list|,
354:46	name|function_name
354:59	argument_list|,
354:61	name|new
354:64	argument_list|,
354:66	name|old
354:69	argument_list|)
354:70	expr_stmt|;
355:9	name|audit_log_session_info
355:31	argument_list|(
355:32	name|ab
355:34	argument_list|)
355:35	expr_stmt|;
356:9	name|rc
356:12	operator|=
356:14	name|audit_log_task_context
356:36	argument_list|(
356:37	name|ab
356:39	argument_list|)
356:40	expr_stmt|;
357:9	if|if
357:12	condition|(
357:13	name|rc
357:15	condition|)
358:17	name|allow_changes
358:31	operator|=
358:33	literal|0
358:34	expr_stmt|;
358:36	comment|/* Something weird, deny request */
359:9	name|audit_log_format
359:25	argument_list|(
359:26	name|ab
359:28	argument_list|,
359:30	literal|" res=%d"
359:39	argument_list|,
359:41	name|allow_changes
359:54	argument_list|)
359:55	expr_stmt|;
360:9	name|audit_log_end
360:22	argument_list|(
360:23	name|ab
360:25	argument_list|)
360:26	expr_stmt|;
361:9	return|return
361:16	name|rc
361:18	return|;
361:19	block|}
-:-	end_function
-:-	begin_function
364:1	specifier|static
364:8	name|int
364:12	name|audit_do_config_change
364:34	parameter_list|(
364:35	name|char
364:40	modifier|*
364:41	name|function_name
364:54	parameter_list|,
364:56	name|u32
364:60	modifier|*
364:61	name|to_change
364:70	parameter_list|,
364:72	name|u32
364:76	name|new
364:79	parameter_list|)
365:1	block|{
366:9	name|int
366:13	name|allow_changes
366:26	decl_stmt|,
366:28	name|rc
366:31	init|=
366:33	literal|0
366:34	decl_stmt|;
367:9	name|u32
367:13	name|old
367:17	init|=
367:19	operator|*
367:20	name|to_change
367:29	decl_stmt|;
369:9	comment|/* check if we are locked */
370:9	if|if
370:12	condition|(
370:13	name|audit_enabled
370:27	operator|==
370:30	name|AUDIT_LOCKED
370:42	condition|)
371:17	name|allow_changes
371:31	operator|=
371:33	literal|0
371:34	expr_stmt|;
372:9	else|else
373:17	name|allow_changes
373:31	operator|=
373:33	literal|1
373:34	expr_stmt|;
375:9	if|if
375:12	condition|(
375:13	name|audit_enabled
375:27	operator|!=
375:30	name|AUDIT_OFF
375:39	condition|)
375:41	block|{
376:17	name|rc
376:20	operator|=
376:22	name|audit_log_config_change
376:45	argument_list|(
376:46	name|function_name
376:59	argument_list|,
376:61	name|new
376:64	argument_list|,
376:66	name|old
376:69	argument_list|,
376:71	name|allow_changes
376:84	argument_list|)
376:85	expr_stmt|;
377:17	if|if
377:20	condition|(
377:21	name|rc
377:23	condition|)
378:25	name|allow_changes
378:39	operator|=
378:41	literal|0
378:42	expr_stmt|;
378:43	block|}
381:9	comment|/* If we are allowed, make the change */
382:9	if|if
382:12	condition|(
382:13	name|allow_changes
382:27	operator|==
382:30	literal|1
382:31	condition|)
383:17	operator|*
383:18	name|to_change
383:28	operator|=
383:30	name|new
383:33	expr_stmt|;
384:9	comment|/* Not allowed, update reason */
385:9	elseif|else
385:14	if|if
385:17	condition|(
385:18	name|rc
385:21	operator|==
385:24	literal|0
385:25	condition|)
386:17	name|rc
386:20	operator|=
386:22	operator|-
386:23	name|EPERM
386:28	expr_stmt|;
387:9	return|return
387:16	name|rc
387:18	return|;
387:19	block|}
-:-	end_function
-:-	begin_function
390:1	specifier|static
390:8	name|int
390:12	name|audit_set_rate_limit
390:32	parameter_list|(
390:33	name|u32
390:37	name|limit
390:42	parameter_list|)
391:1	block|{
392:9	return|return
392:16	name|audit_do_config_change
392:38	argument_list|(
392:39	literal|"audit_rate_limit"
392:57	argument_list|,
392:59	operator|&
392:60	name|audit_rate_limit
392:76	argument_list|,
392:78	name|limit
392:83	argument_list|)
392:84	return|;
392:85	block|}
-:-	end_function
-:-	begin_function
395:1	specifier|static
395:8	name|int
395:12	name|audit_set_backlog_limit
395:35	parameter_list|(
395:36	name|u32
395:40	name|limit
395:45	parameter_list|)
396:1	block|{
397:9	return|return
397:16	name|audit_do_config_change
397:38	argument_list|(
397:39	literal|"audit_backlog_limit"
397:60	argument_list|,
397:62	operator|&
397:63	name|audit_backlog_limit
397:82	argument_list|,
397:84	name|limit
397:89	argument_list|)
397:90	return|;
397:91	block|}
-:-	end_function
-:-	begin_function
400:1	specifier|static
400:8	name|int
400:12	name|audit_set_backlog_wait_time
400:39	parameter_list|(
400:40	name|u32
400:44	name|timeout
400:51	parameter_list|)
401:1	block|{
402:9	return|return
402:16	name|audit_do_config_change
402:38	argument_list|(
402:39	literal|"audit_backlog_wait_time"
402:64	argument_list|,
403:39	operator|&
403:40	name|audit_backlog_wait_time
403:63	argument_list|,
403:65	name|timeout
403:72	argument_list|)
403:73	return|;
403:74	block|}
-:-	end_function
-:-	begin_function
406:1	specifier|static
406:8	name|int
406:12	name|audit_set_enabled
406:29	parameter_list|(
406:30	name|u32
406:34	name|state
406:39	parameter_list|)
407:1	block|{
408:9	name|int
408:13	name|rc
408:15	decl_stmt|;
409:9	if|if
409:12	condition|(
409:13	name|state
409:19	operator|>
409:21	name|AUDIT_LOCKED
409:33	condition|)
410:17	return|return
410:24	operator|-
410:25	name|EINVAL
410:31	return|;
412:9	name|rc
412:12	operator|=
412:15	name|audit_do_config_change
412:37	argument_list|(
412:38	literal|"audit_enabled"
412:53	argument_list|,
412:55	operator|&
412:56	name|audit_enabled
412:69	argument_list|,
412:71	name|state
412:76	argument_list|)
412:77	expr_stmt|;
413:9	if|if
413:12	condition|(
413:13	operator|!
413:14	name|rc
413:16	condition|)
414:17	name|audit_ever_enabled
414:36	operator||=
414:39	operator|!
414:40	operator|!
414:41	name|state
414:46	expr_stmt|;
416:9	return|return
416:16	name|rc
416:18	return|;
416:19	block|}
-:-	end_function
-:-	begin_function
419:1	specifier|static
419:8	name|int
419:12	name|audit_set_failure
419:29	parameter_list|(
419:30	name|u32
419:34	name|state
419:39	parameter_list|)
420:1	block|{
421:9	if|if
421:12	condition|(
421:13	name|state
421:19	operator|!=
421:22	name|AUDIT_FAIL_SILENT
422:13	operator|&&
422:16	name|state
422:22	operator|!=
422:25	name|AUDIT_FAIL_PRINTK
423:13	operator|&&
423:16	name|state
423:22	operator|!=
423:25	name|AUDIT_FAIL_PANIC
423:41	condition|)
424:17	return|return
424:24	operator|-
424:25	name|EINVAL
424:31	return|;
426:9	return|return
426:16	name|audit_do_config_change
426:38	argument_list|(
426:39	literal|"audit_failure"
426:54	argument_list|,
426:56	operator|&
426:57	name|audit_failure
426:70	argument_list|,
426:72	name|state
426:77	argument_list|)
426:78	return|;
426:79	block|}
-:-	end_function
-:-	begin_comment
429:1	comment|/**  * auditd_set - Set/Reset the auditd connection state  * @pid: auditd PID  * @portid: auditd netlink portid  * @net: auditd network namespace pointer  *  * Description:  * This function will obtain and drop network namespace references as  * necessary.  */
-:-	end_comment
-:-	begin_function
439:1	specifier|static
439:8	name|void
439:13	name|auditd_set
439:23	parameter_list|(
439:24	name|int
439:28	name|pid
439:31	parameter_list|,
439:33	name|u32
439:37	name|portid
439:43	parameter_list|,
439:45	name|struct
439:52	name|net
439:56	modifier|*
439:57	name|net
439:60	parameter_list|)
440:1	block|{
441:9	name|unsigned
441:18	name|long
441:23	name|flags
441:28	decl_stmt|;
443:9	name|spin_lock_irqsave
443:26	argument_list|(
443:27	operator|&
443:28	name|auditd_conn
443:39	operator|.
443:40	name|lock
443:44	argument_list|,
443:46	name|flags
443:51	argument_list|)
443:52	expr_stmt|;
444:9	name|auditd_conn
444:20	operator|.
444:21	name|pid
444:25	operator|=
444:27	name|pid
444:30	expr_stmt|;
445:9	name|auditd_conn
445:20	operator|.
445:21	name|portid
445:28	operator|=
445:30	name|portid
445:36	expr_stmt|;
446:9	if|if
446:12	condition|(
446:13	name|auditd_conn
446:24	operator|.
446:25	name|net
446:28	condition|)
447:17	name|put_net
447:24	argument_list|(
447:25	name|auditd_conn
447:36	operator|.
447:37	name|net
447:40	argument_list|)
447:41	expr_stmt|;
448:9	if|if
448:12	condition|(
448:13	name|net
448:16	condition|)
449:17	name|auditd_conn
449:28	operator|.
449:29	name|net
449:33	operator|=
449:35	name|get_net
449:42	argument_list|(
449:43	name|net
449:46	argument_list|)
449:47	expr_stmt|;
450:9	else|else
451:17	name|auditd_conn
451:28	operator|.
451:29	name|net
451:33	operator|=
451:35	name|NULL
451:39	expr_stmt|;
452:9	name|spin_unlock_irqrestore
452:31	argument_list|(
452:32	operator|&
452:33	name|auditd_conn
452:44	operator|.
452:45	name|lock
452:49	argument_list|,
452:51	name|flags
452:56	argument_list|)
452:57	expr_stmt|;
452:58	block|}
-:-	end_function
-:-	begin_comment
455:1	comment|/**  * kauditd_print_skb - Print the audit record to the ring buffer  * @skb: audit record  *  * Whatever the reason, this packet may not make it to the auditd connection  * so write it via printk so the information isn't completely lost.  */
-:-	end_comment
-:-	begin_function
462:1	specifier|static
462:8	name|void
462:13	name|kauditd_printk_skb
462:31	parameter_list|(
462:32	name|struct
462:39	name|sk_buff
462:47	modifier|*
462:48	name|skb
462:51	parameter_list|)
463:1	block|{
464:9	name|struct
464:16	name|nlmsghdr
464:25	modifier|*
464:26	name|nlh
464:30	init|=
464:32	name|nlmsg_hdr
464:41	argument_list|(
464:42	name|skb
464:45	argument_list|)
464:46	decl_stmt|;
465:9	name|char
465:14	modifier|*
465:15	name|data
465:20	init|=
465:22	name|nlmsg_data
465:32	argument_list|(
465:33	name|nlh
465:36	argument_list|)
465:37	decl_stmt|;
467:9	if|if
467:12	condition|(
467:13	name|nlh
467:16	operator|->
467:18	name|nlmsg_type
467:29	operator|!=
467:32	name|AUDIT_EOE
467:42	operator|&&
467:45	name|printk_ratelimit
467:61	argument_list|()
467:63	condition|)
468:17	name|pr_notice
468:26	argument_list|(
468:27	literal|"type=%d %s\n"
468:41	argument_list|,
468:43	name|nlh
468:46	operator|->
468:48	name|nlmsg_type
468:58	argument_list|,
468:60	name|data
468:64	argument_list|)
468:65	expr_stmt|;
468:66	block|}
-:-	end_function
-:-	begin_comment
471:1	comment|/**  * kauditd_rehold_skb - Handle a audit record send failure in the hold queue  * @skb: audit record  *  * Description:  * This should only be used by the kauditd_thread when it fails to flush the  * hold queue.  */
-:-	end_comment
-:-	begin_function
479:1	specifier|static
479:8	name|void
479:13	name|kauditd_rehold_skb
479:31	parameter_list|(
479:32	name|struct
479:39	name|sk_buff
479:47	modifier|*
479:48	name|skb
479:51	parameter_list|)
480:1	block|{
481:9	comment|/* put the record back in the queue at the same place */
482:9	name|skb_queue_head
482:23	argument_list|(
482:24	operator|&
482:25	name|audit_hold_queue
482:41	argument_list|,
482:43	name|skb
482:46	argument_list|)
482:47	expr_stmt|;
482:48	block|}
-:-	end_function
-:-	begin_comment
485:1	comment|/**  * kauditd_hold_skb - Queue an audit record, waiting for auditd  * @skb: audit record  *  * Description:  * Queue the audit record, waiting for an instance of auditd.  When this  * function is called we haven't given up yet on sending the record, but things  * are not looking good.  The first thing we want to do is try to write the  * record via printk and then see if we want to try and hold on to the record  * and queue it, if we have room.  If we want to hold on to the record, but we  * don't have room, record a record lost message.  */
-:-	end_comment
-:-	begin_function
497:1	specifier|static
497:8	name|void
497:13	name|kauditd_hold_skb
497:29	parameter_list|(
497:30	name|struct
497:37	name|sk_buff
497:45	modifier|*
497:46	name|skb
497:49	parameter_list|)
498:1	block|{
499:9	comment|/* at this point it is uncertain if we will ever send this to auditd so 	 * try to send the message via printk before we go any further */
501:9	name|kauditd_printk_skb
501:27	argument_list|(
501:28	name|skb
501:31	argument_list|)
501:32	expr_stmt|;
503:9	comment|/* can we just silently drop the message? */
504:9	if|if
504:12	condition|(
504:13	operator|!
504:14	name|audit_default
504:27	condition|)
504:29	block|{
505:17	name|kfree_skb
505:26	argument_list|(
505:27	name|skb
505:30	argument_list|)
505:31	expr_stmt|;
506:17	return|return;
506:24	block|}
509:9	comment|/* if we have room, queue the message */
510:9	if|if
510:12	condition|(
510:13	operator|!
510:14	name|audit_backlog_limit
510:34	operator|||
511:13	name|skb_queue_len
511:26	argument_list|(
511:27	operator|&
511:28	name|audit_hold_queue
511:44	argument_list|)
511:46	operator|<
511:48	name|audit_backlog_limit
511:67	condition|)
511:69	block|{
512:17	name|skb_queue_tail
512:31	argument_list|(
512:32	operator|&
512:33	name|audit_hold_queue
512:49	argument_list|,
512:51	name|skb
512:54	argument_list|)
512:55	expr_stmt|;
513:17	return|return;
513:24	block|}
516:9	comment|/* we have no other options - drop the message */
517:9	name|audit_log_lost
517:23	argument_list|(
517:24	literal|"kauditd hold queue overflow"
517:53	argument_list|)
517:54	expr_stmt|;
518:9	name|kfree_skb
518:18	argument_list|(
518:19	name|skb
518:22	argument_list|)
518:23	expr_stmt|;
518:24	block|}
-:-	end_function
-:-	begin_comment
521:1	comment|/**  * kauditd_retry_skb - Queue an audit record, attempt to send again to auditd  * @skb: audit record  *  * Description:  * Not as serious as kauditd_hold_skb() as we still have a connected auditd,  * but for some reason we are having problems sending it audit records so  * queue the given record and attempt to resend.  */
-:-	end_comment
-:-	begin_function
530:1	specifier|static
530:8	name|void
530:13	name|kauditd_retry_skb
530:30	parameter_list|(
530:31	name|struct
530:38	name|sk_buff
530:46	modifier|*
530:47	name|skb
530:50	parameter_list|)
531:1	block|{
532:9	comment|/* NOTE: because records should only live in the retry queue for a 	 * short period of time, before either being sent or moved to the hold 	 * queue, we don't currently enforce a limit on this queue */
535:9	name|skb_queue_tail
535:23	argument_list|(
535:24	operator|&
535:25	name|audit_retry_queue
535:42	argument_list|,
535:44	name|skb
535:47	argument_list|)
535:48	expr_stmt|;
535:49	block|}
-:-	end_function
-:-	begin_comment
538:1	comment|/**  * auditd_reset - Disconnect the auditd connection  *  * Description:  * Break the auditd/kauditd connection and move all the queued records into the  * hold queue in case auditd reconnects.  */
-:-	end_comment
-:-	begin_function
545:1	specifier|static
545:8	name|void
545:13	name|auditd_reset
545:25	parameter_list|(
545:26	name|void
545:30	parameter_list|)
546:1	block|{
547:9	name|struct
547:16	name|sk_buff
547:24	modifier|*
547:25	name|skb
547:28	decl_stmt|;
549:9	comment|/* if it isn't already broken, break the connection */
550:9	name|rcu_read_lock
550:22	argument_list|()
550:24	expr_stmt|;
551:9	if|if
551:12	condition|(
551:13	name|auditd_conn
551:24	operator|.
551:25	name|pid
551:28	condition|)
552:17	name|auditd_set
552:27	argument_list|(
552:28	literal|0
552:29	argument_list|,
552:31	literal|0
552:32	argument_list|,
552:34	name|NULL
552:38	argument_list|)
552:39	expr_stmt|;
553:9	name|rcu_read_unlock
553:24	argument_list|()
553:26	expr_stmt|;
555:9	comment|/* flush all of the main and retry queues to the hold queue */
556:9	while|while
556:15	condition|(
556:16	operator|(
556:17	name|skb
556:21	operator|=
556:23	name|skb_dequeue
556:34	argument_list|(
556:35	operator|&
556:36	name|audit_retry_queue
556:53	argument_list|)
556:54	operator|)
556:55	condition|)
557:17	name|kauditd_hold_skb
557:33	argument_list|(
557:34	name|skb
557:37	argument_list|)
557:38	expr_stmt|;
558:9	while|while
558:15	condition|(
558:16	operator|(
558:17	name|skb
558:21	operator|=
558:23	name|skb_dequeue
558:34	argument_list|(
558:35	operator|&
558:36	name|audit_queue
558:47	argument_list|)
558:48	operator|)
558:49	condition|)
559:17	name|kauditd_hold_skb
559:33	argument_list|(
559:34	name|skb
559:37	argument_list|)
559:38	expr_stmt|;
559:39	block|}
-:-	end_function
-:-	begin_comment
562:1	comment|/**  * auditd_send_unicast_skb - Send a record via unicast to auditd  * @skb: audit record  *  * Description:  * Send a skb to the audit daemon, returns positive/zero values on success and  * negative values on failure; in all cases the skb will be consumed by this  * function.  If the send results in -ECONNREFUSED the connection with auditd  * will be reset.  This function may sleep so callers should not hold any locks  * where this would cause a problem.  */
-:-	end_comment
-:-	begin_function
573:1	specifier|static
573:8	name|int
573:12	name|auditd_send_unicast_skb
573:35	parameter_list|(
573:36	name|struct
573:43	name|sk_buff
573:51	modifier|*
573:52	name|skb
573:55	parameter_list|)
574:1	block|{
575:9	name|int
575:13	name|rc
575:15	decl_stmt|;
576:9	name|u32
576:13	name|portid
576:19	decl_stmt|;
577:9	name|struct
577:16	name|net
577:20	modifier|*
577:21	name|net
577:24	decl_stmt|;
578:9	name|struct
578:16	name|sock
578:21	modifier|*
578:22	name|sk
578:24	decl_stmt|;
580:9	comment|/* NOTE: we can't call netlink_unicast while in the RCU section so 	 *       take a reference to the network namespace and grab local 	 *       copies of the namespace, the sock, and the portid; the 	 *       namespace and sock aren't going to go away while we hold a 	 *       reference and if the portid does become invalid after the RCU 	 *       section netlink_unicast() should safely return an error */
587:9	name|rcu_read_lock
587:22	argument_list|()
587:24	expr_stmt|;
588:9	if|if
588:12	condition|(
588:13	operator|!
588:14	name|auditd_conn
588:25	operator|.
588:26	name|pid
588:29	condition|)
588:31	block|{
589:17	name|rcu_read_unlock
589:32	argument_list|()
589:34	expr_stmt|;
590:17	name|rc
590:20	operator|=
590:22	operator|-
590:23	name|ECONNREFUSED
590:35	expr_stmt|;
591:17	goto|goto
591:22	name|err
591:25	goto|;
591:26	block|}
593:9	name|net
593:13	operator|=
593:15	name|auditd_conn
593:26	operator|.
593:27	name|net
593:30	expr_stmt|;
594:9	name|get_net
594:16	argument_list|(
594:17	name|net
594:20	argument_list|)
594:21	expr_stmt|;
595:9	name|sk
595:12	operator|=
595:14	name|audit_get_sk
595:26	argument_list|(
595:27	name|net
595:30	argument_list|)
595:31	expr_stmt|;
596:9	name|portid
596:16	operator|=
596:18	name|auditd_conn
596:29	operator|.
596:30	name|portid
596:36	expr_stmt|;
597:9	name|rcu_read_unlock
597:24	argument_list|()
597:26	expr_stmt|;
599:9	name|rc
599:12	operator|=
599:14	name|netlink_unicast
599:29	argument_list|(
599:30	name|sk
599:32	argument_list|,
599:34	name|skb
599:37	argument_list|,
599:39	name|portid
599:45	argument_list|,
599:47	literal|0
599:48	argument_list|)
599:49	expr_stmt|;
600:9	name|put_net
600:16	argument_list|(
600:17	name|net
600:20	argument_list|)
600:21	expr_stmt|;
601:9	if|if
601:12	condition|(
601:13	name|rc
601:16	operator|<
601:18	literal|0
601:19	condition|)
602:17	goto|goto
602:22	name|err
602:25	goto|;
604:9	return|return
604:16	name|rc
604:18	return|;
606:1	name|err
606:4	label|:
607:9	if|if
607:12	condition|(
607:13	name|rc
607:16	operator|==
607:19	operator|-
607:20	name|ECONNREFUSED
607:32	condition|)
608:17	name|auditd_reset
608:29	argument_list|()
608:31	expr_stmt|;
609:9	return|return
609:16	name|rc
609:18	return|;
609:19	block|}
-:-	end_function
-:-	begin_comment
612:1	comment|/**  * kauditd_send_queue - Helper for kauditd_thread to flush skb queues  * @sk: the sending sock  * @portid: the netlink destination  * @queue: the skb queue to process  * @retry_limit: limit on number of netlink unicast failures  * @skb_hook: per-skb hook for additional processing  * @err_hook: hook called if the skb fails the netlink unicast send  *  * Description:  * Run through the given queue and attempt to send the audit records to auditd,  * returns zero on success, negative values on failure.  It is up to the caller  * to ensure that the @sk is valid for the duration of this function.  *  */
-:-	end_comment
-:-	begin_function
627:1	specifier|static
627:8	name|int
627:12	name|kauditd_send_queue
627:30	parameter_list|(
627:31	name|struct
627:38	name|sock
627:43	modifier|*
627:44	name|sk
627:46	parameter_list|,
627:48	name|u32
627:52	name|portid
627:58	parameter_list|,
628:31	name|struct
628:38	name|sk_buff_head
628:51	modifier|*
628:52	name|queue
628:57	parameter_list|,
629:31	name|unsigned
629:40	name|int
629:44	name|retry_limit
629:55	parameter_list|,
630:31	name|void
630:35	function_decl|(
630:37	modifier|*
630:38	name|skb_hook
630:46	function_decl|)
630:47	parameter_list|(
630:48	name|struct
630:55	name|sk_buff
630:63	modifier|*
630:64	name|skb
630:67	parameter_list|)
630:68	parameter_list|,
631:31	name|void
631:35	function_decl|(
631:37	modifier|*
631:38	name|err_hook
631:46	function_decl|)
631:47	parameter_list|(
631:48	name|struct
631:55	name|sk_buff
631:63	modifier|*
631:64	name|skb
631:67	parameter_list|)
631:68	parameter_list|)
632:1	block|{
633:9	name|int
633:13	name|rc
633:16	init|=
633:18	literal|0
633:19	decl_stmt|;
634:9	name|struct
634:16	name|sk_buff
634:24	modifier|*
634:25	name|skb
634:28	decl_stmt|;
635:9	specifier|static
635:16	name|unsigned
635:25	name|int
635:29	name|failed
635:36	init|=
635:38	literal|0
635:39	decl_stmt|;
637:9	comment|/* NOTE: kauditd_thread takes care of all our locking, we just use 	 *       the netlink info passed to us (e.g. sk and portid) */
640:9	while|while
640:15	condition|(
640:16	operator|(
640:17	name|skb
640:21	operator|=
640:23	name|skb_dequeue
640:34	argument_list|(
640:35	name|queue
640:40	argument_list|)
640:41	operator|)
640:42	condition|)
640:44	block|{
641:17	comment|/* call the skb_hook for each skb we touch */
642:17	if|if
642:20	condition|(
642:21	name|skb_hook
642:29	condition|)
643:25	call|(
643:26	modifier|*
643:27	name|skb_hook
643:35	call|)
643:36	argument_list|(
643:37	name|skb
643:40	argument_list|)
643:41	expr_stmt|;
645:17	comment|/* can we send to anyone via unicast? */
646:17	if|if
646:20	condition|(
646:21	operator|!
646:22	name|sk
646:24	condition|)
646:26	block|{
647:25	if|if
647:28	condition|(
647:29	name|err_hook
647:37	condition|)
648:33	call|(
648:34	modifier|*
648:35	name|err_hook
648:43	call|)
648:44	argument_list|(
648:45	name|skb
648:48	argument_list|)
648:49	expr_stmt|;
649:25	continue|continue;
649:34	block|}
652:17	comment|/* grab an extra skb reference in case of error */
653:17	name|skb_get
653:24	argument_list|(
653:25	name|skb
653:28	argument_list|)
653:29	expr_stmt|;
654:17	name|rc
654:20	operator|=
654:22	name|netlink_unicast
654:37	argument_list|(
654:38	name|sk
654:40	argument_list|,
654:42	name|skb
654:45	argument_list|,
654:47	name|portid
654:53	argument_list|,
654:55	literal|0
654:56	argument_list|)
654:57	expr_stmt|;
655:17	if|if
655:20	condition|(
655:21	name|rc
655:24	operator|<
655:26	literal|0
655:27	condition|)
655:29	block|{
656:25	comment|/* fatal failure for our queue flush attempt? */
657:25	if|if
657:28	condition|(
657:29	operator|++
657:31	name|failed
657:38	operator|>=
657:41	name|retry_limit
657:53	operator|||
658:29	name|rc
658:32	operator|==
658:35	operator|-
658:36	name|ECONNREFUSED
658:49	operator|||
658:52	name|rc
658:55	operator|==
658:58	operator|-
658:59	name|EPERM
658:64	condition|)
658:66	block|{
659:33	comment|/* yes - error processing for the queue */
660:33	name|sk
660:36	operator|=
660:38	name|NULL
660:42	expr_stmt|;
661:33	if|if
661:36	condition|(
661:37	name|err_hook
661:45	condition|)
662:41	call|(
662:42	modifier|*
662:43	name|err_hook
662:51	call|)
662:52	argument_list|(
662:53	name|skb
662:56	argument_list|)
662:57	expr_stmt|;
663:33	if|if
663:36	condition|(
663:37	operator|!
663:38	name|skb_hook
663:46	condition|)
664:41	goto|goto
664:46	name|out
664:49	goto|;
665:33	comment|/* keep processing with the skb_hook */
666:33	continue|continue;
666:42	block|}
667:27	else|else
668:33	comment|/* no - requeue to preserve ordering */
669:33	name|skb_queue_head
669:47	argument_list|(
669:48	name|queue
669:53	argument_list|,
669:55	name|skb
669:58	argument_list|)
669:59	expr_stmt|;
669:60	block|}
670:19	else|else
670:24	block|{
671:25	comment|/* it worked - drop the extra reference and continue */
672:25	name|consume_skb
672:36	argument_list|(
672:37	name|skb
672:40	argument_list|)
672:41	expr_stmt|;
673:25	name|failed
673:32	operator|=
673:34	literal|0
673:35	expr_stmt|;
673:36	block|}
674:18	block|}
677:1	name|out
677:4	label|:
678:9	return|return
678:16	operator|(
678:17	name|rc
678:20	operator|>=
678:23	literal|0
678:24	condition|?
678:27	literal|0
678:29	else|:
678:31	name|rc
678:33	operator|)
678:34	return|;
678:35	block|}
-:-	end_function
-:-	begin_comment
681:1	comment|/*  * kauditd_send_multicast_skb - Send a record to any multicast listeners  * @skb: audit record  *  * Description:  * Write a multicast message to anyone listening in the initial network  * namespace.  This function doesn't consume an skb as might be expected since  * it has to copy it anyways.  */
-:-	end_comment
-:-	begin_function
690:1	specifier|static
690:8	name|void
690:13	name|kauditd_send_multicast_skb
690:39	parameter_list|(
690:40	name|struct
690:47	name|sk_buff
690:55	modifier|*
690:56	name|skb
690:59	parameter_list|)
691:1	block|{
692:9	name|struct
692:16	name|sk_buff
692:24	modifier|*
692:25	name|copy
692:29	decl_stmt|;
693:9	name|struct
693:16	name|sock
693:21	modifier|*
693:22	name|sock
693:27	init|=
693:29	name|audit_get_sk
693:41	argument_list|(
693:42	operator|&
693:43	name|init_net
693:51	argument_list|)
693:52	decl_stmt|;
694:9	name|struct
694:16	name|nlmsghdr
694:25	modifier|*
694:26	name|nlh
694:29	decl_stmt|;
696:9	comment|/* NOTE: we are not taking an additional reference for init_net since 	 *       we don't have to worry about it going away */
699:9	if|if
699:12	condition|(
699:13	operator|!
699:14	name|netlink_has_listeners
699:35	argument_list|(
699:36	name|sock
699:40	argument_list|,
699:42	name|AUDIT_NLGRP_READLOG
699:61	argument_list|)
699:62	condition|)
700:17	return|return;
702:9	comment|/* 	 * The seemingly wasteful skb_copy() rather than bumping the refcount 	 * using skb_get() is necessary because non-standard mods are made to 	 * the skb by the original kaudit unicast socket send routine.  The 	 * existing auditd daemon assumes this breakage.  Fixing this would 	 * require co-ordinating a change in the established protocol between 	 * the kaudit kernel subsystem and the auditd userspace code.  There is 	 * no reason for new multicast clients to continue with this 	 * non-compliance. 	 */
712:9	name|copy
712:14	operator|=
712:16	name|skb_copy
712:24	argument_list|(
712:25	name|skb
712:28	argument_list|,
712:30	name|GFP_KERNEL
712:40	argument_list|)
712:41	expr_stmt|;
713:9	if|if
713:12	condition|(
713:13	operator|!
713:14	name|copy
713:18	condition|)
714:17	return|return;
715:9	name|nlh
715:13	operator|=
715:15	name|nlmsg_hdr
715:24	argument_list|(
715:25	name|copy
715:29	argument_list|)
715:30	expr_stmt|;
716:9	name|nlh
716:12	operator|->
716:14	name|nlmsg_len
716:24	operator|=
716:26	name|skb
716:29	operator|->
716:31	name|len
716:34	expr_stmt|;
718:9	name|nlmsg_multicast
718:24	argument_list|(
718:25	name|sock
718:29	argument_list|,
718:31	name|copy
718:35	argument_list|,
718:37	literal|0
718:38	argument_list|,
718:40	name|AUDIT_NLGRP_READLOG
718:59	argument_list|,
718:61	name|GFP_KERNEL
718:71	argument_list|)
718:72	expr_stmt|;
718:73	block|}
-:-	end_function
-:-	begin_comment
721:1	comment|/**  * kauditd_thread - Worker thread to send audit records to userspace  * @dummy: unused  */
-:-	end_comment
-:-	begin_function
725:1	specifier|static
725:8	name|int
725:12	name|kauditd_thread
725:26	parameter_list|(
725:27	name|void
725:32	modifier|*
725:33	name|dummy
725:38	parameter_list|)
726:1	block|{
727:9	name|int
727:13	name|rc
727:15	decl_stmt|;
728:9	name|u32
728:13	name|portid
728:20	init|=
728:22	literal|0
728:23	decl_stmt|;
729:9	name|struct
729:16	name|net
729:20	modifier|*
729:21	name|net
729:25	init|=
729:27	name|NULL
729:31	decl_stmt|;
730:9	name|struct
730:16	name|sock
730:21	modifier|*
730:22	name|sk
730:25	init|=
730:27	name|NULL
730:31	decl_stmt|;
732:1	define|#
732:2	directive|define
732:9	name|UNICAST_RETRIES
732:25	value|5
734:9	name|set_freezable
734:22	argument_list|()
734:24	expr_stmt|;
735:9	while|while
735:15	condition|(
735:16	operator|!
735:17	name|kthread_should_stop
735:36	argument_list|()
735:38	condition|)
735:40	block|{
736:17	comment|/* NOTE: see the lock comments in auditd_send_unicast_skb() */
737:17	name|rcu_read_lock
737:30	argument_list|()
737:32	expr_stmt|;
738:17	if|if
738:20	condition|(
738:21	operator|!
738:22	name|auditd_conn
738:33	operator|.
738:34	name|pid
738:37	condition|)
738:39	block|{
739:25	name|rcu_read_unlock
739:40	argument_list|()
739:42	expr_stmt|;
740:25	goto|goto
740:30	name|main_queue
740:40	goto|;
740:41	block|}
742:17	name|net
742:21	operator|=
742:23	name|auditd_conn
742:34	operator|.
742:35	name|net
742:38	expr_stmt|;
743:17	name|get_net
743:24	argument_list|(
743:25	name|net
743:28	argument_list|)
743:29	expr_stmt|;
744:17	name|sk
744:20	operator|=
744:22	name|audit_get_sk
744:34	argument_list|(
744:35	name|net
744:38	argument_list|)
744:39	expr_stmt|;
745:17	name|portid
745:24	operator|=
745:26	name|auditd_conn
745:37	operator|.
745:38	name|portid
745:44	expr_stmt|;
746:17	name|rcu_read_unlock
746:32	argument_list|()
746:34	expr_stmt|;
748:17	comment|/* attempt to flush the hold queue */
749:17	name|rc
749:20	operator|=
749:22	name|kauditd_send_queue
749:40	argument_list|(
749:41	name|sk
749:43	argument_list|,
749:45	name|portid
749:51	argument_list|,
750:41	operator|&
750:42	name|audit_hold_queue
750:58	argument_list|,
750:60	name|UNICAST_RETRIES
750:75	argument_list|,
751:41	name|NULL
751:45	argument_list|,
751:47	name|kauditd_rehold_skb
751:65	argument_list|)
751:66	expr_stmt|;
752:17	if|if
752:20	condition|(
752:21	name|rc
752:24	operator|<
752:26	literal|0
752:27	condition|)
752:29	block|{
753:25	name|sk
753:28	operator|=
753:30	name|NULL
753:34	expr_stmt|;
754:25	name|auditd_reset
754:37	argument_list|()
754:39	expr_stmt|;
755:25	goto|goto
755:30	name|main_queue
755:40	goto|;
755:41	block|}
758:17	comment|/* attempt to flush the retry queue */
759:17	name|rc
759:20	operator|=
759:22	name|kauditd_send_queue
759:40	argument_list|(
759:41	name|sk
759:43	argument_list|,
759:45	name|portid
759:51	argument_list|,
760:41	operator|&
760:42	name|audit_retry_queue
760:59	argument_list|,
760:61	name|UNICAST_RETRIES
760:76	argument_list|,
761:41	name|NULL
761:45	argument_list|,
761:47	name|kauditd_hold_skb
761:63	argument_list|)
761:64	expr_stmt|;
762:17	if|if
762:20	condition|(
762:21	name|rc
762:24	operator|<
762:26	literal|0
762:27	condition|)
762:29	block|{
763:25	name|sk
763:28	operator|=
763:30	name|NULL
763:34	expr_stmt|;
764:25	name|auditd_reset
764:37	argument_list|()
764:39	expr_stmt|;
765:25	goto|goto
765:30	name|main_queue
765:40	goto|;
765:41	block|}
768:1	name|main_queue
768:11	label|:
769:17	comment|/* process the main queue - do the multicast send and attempt 		 * unicast, dump failed record sends to the retry queue; if 		 * sk == NULL due to previous failures we will just do the 		 * multicast send and move the record to the retry queue */
773:17	name|rc
773:20	operator|=
773:22	name|kauditd_send_queue
773:40	argument_list|(
773:41	name|sk
773:43	argument_list|,
773:45	name|portid
773:51	argument_list|,
773:53	operator|&
773:54	name|audit_queue
773:65	argument_list|,
773:67	literal|1
773:68	argument_list|,
774:41	name|kauditd_send_multicast_skb
774:67	argument_list|,
775:41	name|kauditd_retry_skb
775:58	argument_list|)
775:59	expr_stmt|;
776:17	if|if
776:20	condition|(
776:21	name|sk
776:24	operator|==
776:27	name|NULL
776:32	operator|||
776:35	name|rc
776:38	operator|<
776:40	literal|0
776:41	condition|)
777:25	name|auditd_reset
777:37	argument_list|()
777:39	expr_stmt|;
778:17	name|sk
778:20	operator|=
778:22	name|NULL
778:26	expr_stmt|;
780:17	comment|/* drop our netns reference, no auditd sends past this line */
781:17	if|if
781:20	condition|(
781:21	name|net
781:24	condition|)
781:26	block|{
782:25	name|put_net
782:32	argument_list|(
782:33	name|net
782:36	argument_list|)
782:37	expr_stmt|;
783:25	name|net
783:29	operator|=
783:31	name|NULL
783:35	expr_stmt|;
783:36	block|}
786:17	comment|/* we have processed all the queues so wake everyone */
787:17	name|wake_up
787:24	argument_list|(
787:25	operator|&
787:26	name|audit_backlog_wait
787:44	argument_list|)
787:45	expr_stmt|;
789:17	comment|/* NOTE: we want to wake up if there is anything on the queue, 		 *       regardless of if an auditd is connected, as we need to 		 *       do the multicast send and rotate records from the 		 *       main queue to the retry/hold queues */
793:17	name|wait_event_freezable
793:37	argument_list|(
793:38	name|kauditd_wait
793:50	argument_list|,
794:38	operator|(
794:39	name|skb_queue_len
794:52	argument_list|(
794:53	operator|&
794:54	name|audit_queue
794:65	argument_list|)
794:66	condition|?
794:69	literal|1
794:71	else|:
794:73	literal|0
794:74	operator|)
794:75	argument_list|)
794:76	expr_stmt|;
794:77	block|}
797:9	return|return
797:16	literal|0
797:17	return|;
797:18	block|}
-:-	end_function
-:-	begin_function
800:1	name|int
800:5	name|audit_send_list
800:20	parameter_list|(
800:21	name|void
800:26	modifier|*
800:27	name|_dest
800:32	parameter_list|)
801:1	block|{
802:9	name|struct
802:16	name|audit_netlink_list
802:35	modifier|*
802:36	name|dest
802:41	init|=
802:43	name|_dest
802:48	decl_stmt|;
803:9	name|struct
803:16	name|sk_buff
803:24	modifier|*
803:25	name|skb
803:28	decl_stmt|;
804:9	name|struct
804:16	name|sock
804:21	modifier|*
804:22	name|sk
804:25	init|=
804:27	name|audit_get_sk
804:39	argument_list|(
804:40	name|dest
804:44	operator|->
804:46	name|net
804:49	argument_list|)
804:50	decl_stmt|;
806:9	comment|/* wait for parent to finish and send an ACK */
807:9	name|mutex_lock
807:19	argument_list|(
807:20	operator|&
807:21	name|audit_cmd_mutex
807:36	argument_list|)
807:37	expr_stmt|;
808:9	name|mutex_unlock
808:21	argument_list|(
808:22	operator|&
808:23	name|audit_cmd_mutex
808:38	argument_list|)
808:39	expr_stmt|;
810:9	while|while
810:15	condition|(
810:16	operator|(
810:17	name|skb
810:21	operator|=
810:23	name|__skb_dequeue
810:36	argument_list|(
810:37	operator|&
810:38	name|dest
810:42	operator|->
810:44	name|q
810:45	argument_list|)
810:46	operator|)
810:48	operator|!=
810:51	name|NULL
810:55	condition|)
811:17	name|netlink_unicast
811:32	argument_list|(
811:33	name|sk
811:35	argument_list|,
811:37	name|skb
811:40	argument_list|,
811:42	name|dest
811:46	operator|->
811:48	name|portid
811:54	argument_list|,
811:56	literal|0
811:57	argument_list|)
811:58	expr_stmt|;
813:9	name|put_net
813:16	argument_list|(
813:17	name|dest
813:21	operator|->
813:23	name|net
813:26	argument_list|)
813:27	expr_stmt|;
814:9	name|kfree
814:14	argument_list|(
814:15	name|dest
814:19	argument_list|)
814:20	expr_stmt|;
816:9	return|return
816:16	literal|0
816:17	return|;
816:18	block|}
-:-	end_function
-:-	begin_function
819:1	name|struct
819:8	name|sk_buff
819:16	modifier|*
819:17	name|audit_make_reply
819:33	parameter_list|(
819:34	name|__u32
819:40	name|portid
819:46	parameter_list|,
819:48	name|int
819:52	name|seq
819:55	parameter_list|,
819:57	name|int
819:61	name|type
819:65	parameter_list|,
819:67	name|int
819:71	name|done
819:75	parameter_list|,
820:34	name|int
820:38	name|multi
820:43	parameter_list|,
820:45	specifier|const
820:51	name|void
820:56	modifier|*
820:57	name|payload
820:64	parameter_list|,
820:66	name|int
820:70	name|size
820:74	parameter_list|)
821:1	block|{
822:9	name|struct
822:16	name|sk_buff
822:25	modifier|*
822:26	name|skb
822:29	decl_stmt|;
823:9	name|struct
823:16	name|nlmsghdr
823:25	modifier|*
823:26	name|nlh
823:29	decl_stmt|;
824:9	name|void
824:25	modifier|*
824:26	name|data
824:30	decl_stmt|;
825:9	name|int
825:25	name|flags
825:31	init|=
825:33	name|multi
825:38	condition|?
825:41	name|NLM_F_MULTI
825:53	else|:
825:55	literal|0
825:56	decl_stmt|;
826:9	name|int
826:25	name|t
826:31	init|=
826:33	name|done
826:37	condition|?
826:41	name|NLMSG_DONE
826:53	else|:
826:55	name|type
826:59	decl_stmt|;
828:9	name|skb
828:13	operator|=
828:15	name|nlmsg_new
828:24	argument_list|(
828:25	name|size
828:29	argument_list|,
828:31	name|GFP_KERNEL
828:41	argument_list|)
828:42	expr_stmt|;
829:9	if|if
829:12	condition|(
829:13	operator|!
829:14	name|skb
829:17	condition|)
830:17	return|return
830:24	name|NULL
830:28	return|;
832:9	name|nlh
832:17	operator|=
832:19	name|nlmsg_put
832:28	argument_list|(
832:29	name|skb
832:32	argument_list|,
832:34	name|portid
832:40	argument_list|,
832:42	name|seq
832:45	argument_list|,
832:47	name|t
832:48	argument_list|,
832:50	name|size
832:54	argument_list|,
832:56	name|flags
832:61	argument_list|)
832:62	expr_stmt|;
833:9	if|if
833:12	condition|(
833:13	operator|!
833:14	name|nlh
833:17	condition|)
834:17	goto|goto
834:22	name|out_kfree_skb
834:35	goto|;
835:9	name|data
835:14	operator|=
835:16	name|nlmsg_data
835:26	argument_list|(
835:27	name|nlh
835:30	argument_list|)
835:31	expr_stmt|;
836:9	name|memcpy
836:15	argument_list|(
836:16	name|data
836:20	argument_list|,
836:22	name|payload
836:29	argument_list|,
836:31	name|size
836:35	argument_list|)
836:36	expr_stmt|;
837:9	return|return
837:16	name|skb
837:19	return|;
839:1	name|out_kfree_skb
839:14	label|:
840:9	name|kfree_skb
840:18	argument_list|(
840:19	name|skb
840:22	argument_list|)
840:23	expr_stmt|;
841:9	return|return
841:16	name|NULL
841:20	return|;
841:21	block|}
-:-	end_function
-:-	begin_function
844:1	specifier|static
844:8	name|int
844:12	name|audit_send_reply_thread
844:35	parameter_list|(
844:36	name|void
844:41	modifier|*
844:42	name|arg
844:45	parameter_list|)
845:1	block|{
846:9	name|struct
846:16	name|audit_reply
846:28	modifier|*
846:29	name|reply
846:35	init|=
846:37	operator|(
846:38	expr|struct
846:45	name|audit_reply
846:57	operator|*
846:58	operator|)
846:59	name|arg
846:62	decl_stmt|;
847:9	name|struct
847:16	name|sock
847:21	modifier|*
847:22	name|sk
847:25	init|=
847:27	name|audit_get_sk
847:39	argument_list|(
847:40	name|reply
847:45	operator|->
847:47	name|net
847:50	argument_list|)
847:51	decl_stmt|;
849:9	name|mutex_lock
849:19	argument_list|(
849:20	operator|&
849:21	name|audit_cmd_mutex
849:36	argument_list|)
849:37	expr_stmt|;
850:9	name|mutex_unlock
850:21	argument_list|(
850:22	operator|&
850:23	name|audit_cmd_mutex
850:38	argument_list|)
850:39	expr_stmt|;
852:9	comment|/* Ignore failure. It'll only happen if the sender goes away, 	   because our timeout is set to infinite. */
854:9	name|netlink_unicast
854:24	argument_list|(
854:25	name|sk
854:27	argument_list|,
854:29	name|reply
854:34	operator|->
854:36	name|skb
854:39	argument_list|,
854:41	name|reply
854:46	operator|->
854:48	name|portid
854:54	argument_list|,
854:56	literal|0
854:57	argument_list|)
854:58	expr_stmt|;
855:9	name|put_net
855:16	argument_list|(
855:17	name|reply
855:22	operator|->
855:24	name|net
855:27	argument_list|)
855:28	expr_stmt|;
856:9	name|kfree
856:14	argument_list|(
856:15	name|reply
856:20	argument_list|)
856:21	expr_stmt|;
857:9	return|return
857:16	literal|0
857:17	return|;
857:18	block|}
-:-	end_function
-:-	begin_comment
860:1	comment|/**  * audit_send_reply - send an audit reply message via netlink  * @request_skb: skb of request we are replying to (used to target the reply)  * @seq: sequence number  * @type: audit message type  * @done: done (last) flag  * @multi: multi-part message flag  * @payload: payload data  * @size: payload size  *  * Allocates an skb, builds the netlink message, and sends it to the port id.  * No failure notifications.  */
-:-	end_comment
-:-	begin_function
873:1	specifier|static
873:8	name|void
873:13	name|audit_send_reply
873:29	parameter_list|(
873:30	name|struct
873:37	name|sk_buff
873:45	modifier|*
873:46	name|request_skb
873:57	parameter_list|,
873:59	name|int
873:63	name|seq
873:66	parameter_list|,
873:68	name|int
873:72	name|type
873:76	parameter_list|,
873:78	name|int
873:82	name|done
873:86	parameter_list|,
874:30	name|int
874:34	name|multi
874:39	parameter_list|,
874:41	specifier|const
874:47	name|void
874:52	modifier|*
874:53	name|payload
874:60	parameter_list|,
874:62	name|int
874:66	name|size
874:70	parameter_list|)
875:1	block|{
876:9	name|u32
876:13	name|portid
876:20	init|=
876:22	name|NETLINK_CB
876:32	argument_list|(
876:33	name|request_skb
876:44	argument_list|)
876:45	operator|.
876:46	name|portid
876:52	decl_stmt|;
877:9	name|struct
877:16	name|net
877:20	modifier|*
877:21	name|net
877:25	init|=
877:27	name|sock_net
877:35	argument_list|(
877:36	name|NETLINK_CB
877:46	argument_list|(
877:47	name|request_skb
877:58	argument_list|)
877:59	operator|.
877:60	name|sk
877:62	argument_list|)
877:63	decl_stmt|;
878:9	name|struct
878:16	name|sk_buff
878:24	modifier|*
878:25	name|skb
878:28	decl_stmt|;
879:9	name|struct
879:16	name|task_struct
879:28	modifier|*
879:29	name|tsk
879:32	decl_stmt|;
880:9	name|struct
880:16	name|audit_reply
880:28	modifier|*
880:29	name|reply
880:35	init|=
880:37	name|kmalloc
880:44	argument_list|(
880:45	sizeof|sizeof
880:51	argument_list|(
880:52	expr|struct
880:59	name|audit_reply
880:70	argument_list|)
880:71	argument_list|,
881:45	name|GFP_KERNEL
881:55	argument_list|)
881:56	decl_stmt|;
883:9	if|if
883:12	condition|(
883:13	operator|!
883:14	name|reply
883:19	condition|)
884:17	return|return;
886:9	name|skb
886:13	operator|=
886:15	name|audit_make_reply
886:31	argument_list|(
886:32	name|portid
886:38	argument_list|,
886:40	name|seq
886:43	argument_list|,
886:45	name|type
886:49	argument_list|,
886:51	name|done
886:55	argument_list|,
886:57	name|multi
886:62	argument_list|,
886:64	name|payload
886:71	argument_list|,
886:73	name|size
886:77	argument_list|)
886:78	expr_stmt|;
887:9	if|if
887:12	condition|(
887:13	operator|!
887:14	name|skb
887:17	condition|)
888:17	goto|goto
888:22	name|out
888:25	goto|;
890:9	name|reply
890:14	operator|->
890:16	name|net
890:20	operator|=
890:22	name|get_net
890:29	argument_list|(
890:30	name|net
890:33	argument_list|)
890:34	expr_stmt|;
891:9	name|reply
891:14	operator|->
891:16	name|portid
891:23	operator|=
891:25	name|portid
891:31	expr_stmt|;
892:9	name|reply
892:14	operator|->
892:16	name|skb
892:20	operator|=
892:22	name|skb
892:25	expr_stmt|;
894:9	name|tsk
894:13	operator|=
894:15	name|kthread_run
894:26	argument_list|(
894:27	name|audit_send_reply_thread
894:50	argument_list|,
894:52	name|reply
894:57	argument_list|,
894:59	literal|"audit_send_reply"
894:77	argument_list|)
894:78	expr_stmt|;
895:9	if|if
895:12	condition|(
895:13	operator|!
895:14	name|IS_ERR
895:20	argument_list|(
895:21	name|tsk
895:24	argument_list|)
895:25	condition|)
896:17	return|return;
897:9	name|kfree_skb
897:18	argument_list|(
897:19	name|skb
897:22	argument_list|)
897:23	expr_stmt|;
898:1	name|out
898:4	label|:
899:9	name|kfree
899:14	argument_list|(
899:15	name|reply
899:20	argument_list|)
899:21	expr_stmt|;
899:22	block|}
-:-	end_function
-:-	begin_comment
902:1	comment|/*  * Check for appropriate CAP_AUDIT_ capabilities on incoming audit  * control messages.  */
-:-	end_comment
-:-	begin_function
906:1	specifier|static
906:8	name|int
906:12	name|audit_netlink_ok
906:28	parameter_list|(
906:29	name|struct
906:36	name|sk_buff
906:44	modifier|*
906:45	name|skb
906:48	parameter_list|,
906:50	name|u16
906:54	name|msg_type
906:62	parameter_list|)
907:1	block|{
908:9	name|int
908:13	name|err
908:17	init|=
908:19	literal|0
908:20	decl_stmt|;
910:9	comment|/* Only support initial user namespace for now. */
911:9	comment|/* 	 * We return ECONNREFUSED because it tricks userspace into thinking 	 * that audit was not configured into the kernel.  Lots of users 	 * configure their PAM stack (because that's what the distro does) 	 * to reject login if unable to send messages to audit.  If we return 	 * ECONNREFUSED the PAM stack thinks the kernel does not have audit 	 * configured in and will let login proceed.  If we return EPERM 	 * userspace will reject all logins.  This should be removed when we 	 * support non init namespaces!! 	 */
921:9	if|if
921:12	condition|(
921:13	name|current_user_ns
921:28	argument_list|()
921:31	operator|!=
921:34	operator|&
921:35	name|init_user_ns
921:47	condition|)
922:17	return|return
922:24	operator|-
922:25	name|ECONNREFUSED
922:37	return|;
924:9	switch|switch
924:16	condition|(
924:17	name|msg_type
924:25	condition|)
924:27	block|{
925:9	case|case
925:14	name|AUDIT_LIST
925:24	case|:
926:9	case|case
926:14	name|AUDIT_ADD
926:23	case|:
927:9	case|case
927:14	name|AUDIT_DEL
927:23	case|:
928:17	return|return
928:24	operator|-
928:25	name|EOPNOTSUPP
928:35	return|;
929:9	case|case
929:14	name|AUDIT_GET
929:23	case|:
930:9	case|case
930:14	name|AUDIT_SET
930:23	case|:
931:9	case|case
931:14	name|AUDIT_GET_FEATURE
931:31	case|:
932:9	case|case
932:14	name|AUDIT_SET_FEATURE
932:31	case|:
933:9	case|case
933:14	name|AUDIT_LIST_RULES
933:30	case|:
934:9	case|case
934:14	name|AUDIT_ADD_RULE
934:28	case|:
935:9	case|case
935:14	name|AUDIT_DEL_RULE
935:28	case|:
936:9	case|case
936:14	name|AUDIT_SIGNAL_INFO
936:31	case|:
937:9	case|case
937:14	name|AUDIT_TTY_GET
937:27	case|:
938:9	case|case
938:14	name|AUDIT_TTY_SET
938:27	case|:
939:9	case|case
939:14	name|AUDIT_TRIM
939:24	case|:
940:9	case|case
940:14	name|AUDIT_MAKE_EQUIV
940:30	case|:
941:17	comment|/* Only support auditd and auditctl in initial pid namespace 		 * for now. */
943:17	if|if
943:20	condition|(
943:21	name|task_active_pid_ns
943:39	argument_list|(
943:40	name|current
943:47	argument_list|)
943:49	operator|!=
943:52	operator|&
943:53	name|init_pid_ns
943:64	condition|)
944:25	return|return
944:32	operator|-
944:33	name|EPERM
944:38	return|;
946:17	if|if
946:20	condition|(
946:21	operator|!
946:22	name|netlink_capable
946:37	argument_list|(
946:38	name|skb
946:41	argument_list|,
946:43	name|CAP_AUDIT_CONTROL
946:60	argument_list|)
946:61	condition|)
947:25	name|err
947:29	operator|=
947:31	operator|-
947:32	name|EPERM
947:37	expr_stmt|;
948:17	break|break;
949:9	case|case
949:14	name|AUDIT_USER
949:24	case|:
950:9	case|case
950:14	name|AUDIT_FIRST_USER_MSG
950:35	operator|...
950:39	name|AUDIT_LAST_USER_MSG
950:58	case|:
951:9	case|case
951:14	name|AUDIT_FIRST_USER_MSG2
951:36	operator|...
951:40	name|AUDIT_LAST_USER_MSG2
951:60	case|:
952:17	if|if
952:20	condition|(
952:21	operator|!
952:22	name|netlink_capable
952:37	argument_list|(
952:38	name|skb
952:41	argument_list|,
952:43	name|CAP_AUDIT_WRITE
952:58	argument_list|)
952:59	condition|)
953:25	name|err
953:29	operator|=
953:31	operator|-
953:32	name|EPERM
953:37	expr_stmt|;
954:17	break|break;
955:9	default|default:
955:19	comment|/* bad msg */
956:17	name|err
956:21	operator|=
956:23	operator|-
956:24	name|EINVAL
956:30	expr_stmt|;
956:31	block|}
959:9	return|return
959:16	name|err
959:19	return|;
959:20	block|}
-:-	end_function
-:-	begin_function
962:1	specifier|static
962:8	name|void
962:13	name|audit_log_common_recv_msg
962:38	parameter_list|(
962:39	name|struct
962:46	name|audit_buffer
962:59	modifier|*
962:60	modifier|*
962:61	name|ab
962:63	parameter_list|,
962:65	name|u16
962:69	name|msg_type
962:77	parameter_list|)
963:1	block|{
964:9	name|uid_t
964:15	name|uid
964:19	init|=
964:21	name|from_kuid
964:30	argument_list|(
964:31	operator|&
964:32	name|init_user_ns
964:44	argument_list|,
964:46	name|current_uid
964:57	argument_list|()
964:59	argument_list|)
964:60	decl_stmt|;
965:9	name|pid_t
965:15	name|pid
965:19	init|=
965:21	name|task_tgid_nr
965:33	argument_list|(
965:34	name|current
965:41	argument_list|)
965:42	decl_stmt|;
967:9	if|if
967:12	condition|(
967:13	operator|!
967:14	name|audit_enabled
967:28	operator|&&
967:31	name|msg_type
967:40	operator|!=
967:43	name|AUDIT_USER_AVC
967:57	condition|)
967:59	block|{
968:17	operator|*
968:18	name|ab
968:21	operator|=
968:23	name|NULL
968:27	expr_stmt|;
969:17	return|return;
969:24	block|}
972:9	operator|*
972:10	name|ab
972:13	operator|=
972:15	name|audit_log_start
972:30	argument_list|(
972:31	name|NULL
972:35	argument_list|,
972:37	name|GFP_KERNEL
972:47	argument_list|,
972:49	name|msg_type
972:57	argument_list|)
972:58	expr_stmt|;
973:9	if|if
973:12	condition|(
973:13	name|unlikely
973:21	argument_list|(
973:22	operator|!
973:23	operator|*
973:24	name|ab
973:26	argument_list|)
973:27	condition|)
974:17	return|return;
975:9	name|audit_log_format
975:25	argument_list|(
975:26	operator|*
975:27	name|ab
975:29	argument_list|,
975:31	literal|"pid=%d uid=%u"
975:46	argument_list|,
975:48	name|pid
975:51	argument_list|,
975:53	name|uid
975:56	argument_list|)
975:57	expr_stmt|;
976:9	name|audit_log_session_info
976:31	argument_list|(
976:32	operator|*
976:33	name|ab
976:35	argument_list|)
976:36	expr_stmt|;
977:9	name|audit_log_task_context
977:31	argument_list|(
977:32	operator|*
977:33	name|ab
977:35	argument_list|)
977:36	expr_stmt|;
977:37	block|}
-:-	end_function
-:-	begin_function
980:1	name|int
980:5	name|is_audit_feature_set
980:25	parameter_list|(
980:26	name|int
980:30	name|i
980:31	parameter_list|)
981:1	block|{
982:9	return|return
982:16	name|af
982:18	operator|.
982:19	name|features
982:28	operator|&
982:30	name|AUDIT_FEATURE_TO_MASK
982:51	argument_list|(
982:52	name|i
982:53	argument_list|)
982:54	return|;
982:55	block|}
-:-	end_function
-:-	begin_function
986:1	specifier|static
986:8	name|int
986:12	name|audit_get_feature
986:29	parameter_list|(
986:30	name|struct
986:37	name|sk_buff
986:45	modifier|*
986:46	name|skb
986:49	parameter_list|)
987:1	block|{
988:9	name|u32
988:13	name|seq
988:16	decl_stmt|;
990:9	name|seq
990:13	operator|=
990:15	name|nlmsg_hdr
990:24	argument_list|(
990:25	name|skb
990:28	argument_list|)
990:29	operator|->
990:31	name|nlmsg_seq
990:40	expr_stmt|;
992:9	name|audit_send_reply
992:25	argument_list|(
992:26	name|skb
992:29	argument_list|,
992:31	name|seq
992:34	argument_list|,
992:36	name|AUDIT_GET_FEATURE
992:53	argument_list|,
992:55	literal|0
992:56	argument_list|,
992:58	literal|0
992:59	argument_list|,
992:61	operator|&
992:62	name|af
992:64	argument_list|,
992:66	sizeof|sizeof
992:72	argument_list|(
992:73	name|af
992:75	argument_list|)
992:76	argument_list|)
992:77	expr_stmt|;
994:9	return|return
994:16	literal|0
994:17	return|;
994:18	block|}
-:-	end_function
-:-	begin_function
997:1	specifier|static
997:8	name|void
997:13	name|audit_log_feature_change
997:37	parameter_list|(
997:38	name|int
997:42	name|which
997:47	parameter_list|,
997:49	name|u32
997:53	name|old_feature
997:64	parameter_list|,
997:66	name|u32
997:70	name|new_feature
997:81	parameter_list|,
998:38	name|u32
998:42	name|old_lock
998:50	parameter_list|,
998:52	name|u32
998:56	name|new_lock
998:64	parameter_list|,
998:66	name|int
998:70	name|res
998:73	parameter_list|)
999:1	block|{
1000:9	name|struct
1000:16	name|audit_buffer
1000:29	modifier|*
1000:30	name|ab
1000:32	decl_stmt|;
1002:9	if|if
1002:12	condition|(
1002:13	name|audit_enabled
1002:27	operator|==
1002:30	name|AUDIT_OFF
1002:39	condition|)
1003:17	return|return;
1005:9	name|ab
1005:12	operator|=
1005:14	name|audit_log_start
1005:29	argument_list|(
1005:30	name|NULL
1005:34	argument_list|,
1005:36	name|GFP_KERNEL
1005:46	argument_list|,
1005:48	name|AUDIT_FEATURE_CHANGE
1005:68	argument_list|)
1005:69	expr_stmt|;
1006:9	name|audit_log_task_info
1006:28	argument_list|(
1006:29	name|ab
1006:31	argument_list|,
1006:33	name|current
1006:40	argument_list|)
1006:41	expr_stmt|;
1007:9	name|audit_log_format
1007:25	argument_list|(
1007:26	name|ab
1007:28	argument_list|,
1007:30	literal|" feature=%s old=%u new=%u old_lock=%u new_lock=%u res=%d"
1007:88	argument_list|,
1008:26	name|audit_feature_names
1008:45	index|[
1008:46	name|which
1008:51	index|]
1008:52	argument_list|,
1008:54	operator|!
1008:55	operator|!
1008:56	name|old_feature
1008:67	argument_list|,
1008:69	operator|!
1008:70	operator|!
1008:71	name|new_feature
1008:82	argument_list|,
1009:26	operator|!
1009:27	operator|!
1009:28	name|old_lock
1009:36	argument_list|,
1009:38	operator|!
1009:39	operator|!
1009:40	name|new_lock
1009:48	argument_list|,
1009:50	name|res
1009:53	argument_list|)
1009:54	expr_stmt|;
1010:9	name|audit_log_end
1010:22	argument_list|(
1010:23	name|ab
1010:25	argument_list|)
1010:26	expr_stmt|;
1010:27	block|}
-:-	end_function
-:-	begin_function
1013:1	specifier|static
1013:8	name|int
1013:12	name|audit_set_feature
1013:29	parameter_list|(
1013:30	name|struct
1013:37	name|sk_buff
1013:45	modifier|*
1013:46	name|skb
1013:49	parameter_list|)
1014:1	block|{
1015:9	name|struct
1015:16	name|audit_features
1015:31	modifier|*
1015:32	name|uaf
1015:35	decl_stmt|;
1016:9	name|int
1016:13	name|i
1016:14	decl_stmt|;
1018:9	name|BUILD_BUG_ON
1018:21	argument_list|(
1018:22	name|AUDIT_LAST_FEATURE
1018:41	operator|+
1018:43	literal|1
1018:45	operator|>
1018:47	name|ARRAY_SIZE
1018:57	argument_list|(
1018:58	name|audit_feature_names
1018:77	argument_list|)
1018:78	argument_list|)
1018:79	expr_stmt|;
1019:9	name|uaf
1019:13	operator|=
1019:15	name|nlmsg_data
1019:25	argument_list|(
1019:26	name|nlmsg_hdr
1019:35	argument_list|(
1019:36	name|skb
1019:39	argument_list|)
1019:40	argument_list|)
1019:41	expr_stmt|;
1021:9	comment|/* if there is ever a version 2 we should handle that here */
1023:9	for|for
1023:13	control|(
1023:14	name|i
1023:16	operator|=
1023:18	literal|0
1023:19	init|;
1023:21	name|i
1023:23	operator|<=
1023:26	name|AUDIT_LAST_FEATURE
1023:44	condition|;
1023:46	name|i
1023:47	operator|++
1023:49	control|)
1023:51	block|{
1024:17	name|u32
1024:21	name|feature
1024:29	init|=
1024:31	name|AUDIT_FEATURE_TO_MASK
1024:52	argument_list|(
1024:53	name|i
1024:54	argument_list|)
1024:55	decl_stmt|;
1025:17	name|u32
1025:21	name|old_feature
1025:32	decl_stmt|,
1025:34	name|new_feature
1025:45	decl_stmt|,
1025:47	name|old_lock
1025:55	decl_stmt|,
1025:57	name|new_lock
1025:65	decl_stmt|;
1027:17	comment|/* if we are not changing this feature, move along */
1028:17	if|if
1028:20	condition|(
1028:21	operator|!
1028:22	operator|(
1028:23	name|feature
1028:31	operator|&
1028:33	name|uaf
1028:36	operator|->
1028:38	name|mask
1028:42	operator|)
1028:43	condition|)
1029:25	continue|continue;
1031:17	name|old_feature
1031:29	operator|=
1031:31	name|af
1031:33	operator|.
1031:34	name|features
1031:43	operator|&
1031:45	name|feature
1031:52	expr_stmt|;
1032:17	name|new_feature
1032:29	operator|=
1032:31	name|uaf
1032:34	operator|->
1032:36	name|features
1032:45	operator|&
1032:47	name|feature
1032:54	expr_stmt|;
1033:17	name|new_lock
1033:26	operator|=
1033:28	operator|(
1033:29	name|uaf
1033:32	operator|->
1033:34	name|lock
1033:39	operator||
1033:41	name|af
1033:43	operator|.
1033:44	name|lock
1033:48	operator|)
1033:50	operator|&
1033:52	name|feature
1033:59	expr_stmt|;
1034:17	name|old_lock
1034:26	operator|=
1034:28	name|af
1034:30	operator|.
1034:31	name|lock
1034:36	operator|&
1034:38	name|feature
1034:45	expr_stmt|;
1036:17	comment|/* are we changing a locked feature? */
1037:17	if|if
1037:20	condition|(
1037:21	name|old_lock
1037:30	operator|&&
1037:33	operator|(
1037:34	name|new_feature
1037:46	operator|!=
1037:49	name|old_feature
1037:60	operator|)
1037:61	condition|)
1037:63	block|{
1038:25	name|audit_log_feature_change
1038:49	argument_list|(
1038:50	name|i
1038:51	argument_list|,
1038:53	name|old_feature
1038:64	argument_list|,
1038:66	name|new_feature
1038:77	argument_list|,
1039:50	name|old_lock
1039:58	argument_list|,
1039:60	name|new_lock
1039:68	argument_list|,
1039:70	literal|0
1039:71	argument_list|)
1039:72	expr_stmt|;
1040:25	return|return
1040:32	operator|-
1040:33	name|EPERM
1040:38	return|;
1040:39	block|}
1041:18	block|}
1043:9	comment|/* nothing invalid, do the changes */
1044:9	for|for
1044:13	control|(
1044:14	name|i
1044:16	operator|=
1044:18	literal|0
1044:19	init|;
1044:21	name|i
1044:23	operator|<=
1044:26	name|AUDIT_LAST_FEATURE
1044:44	condition|;
1044:46	name|i
1044:47	operator|++
1044:49	control|)
1044:51	block|{
1045:17	name|u32
1045:21	name|feature
1045:29	init|=
1045:31	name|AUDIT_FEATURE_TO_MASK
1045:52	argument_list|(
1045:53	name|i
1045:54	argument_list|)
1045:55	decl_stmt|;
1046:17	name|u32
1046:21	name|old_feature
1046:32	decl_stmt|,
1046:34	name|new_feature
1046:45	decl_stmt|,
1046:47	name|old_lock
1046:55	decl_stmt|,
1046:57	name|new_lock
1046:65	decl_stmt|;
1048:17	comment|/* if we are not changing this feature, move along */
1049:17	if|if
1049:20	condition|(
1049:21	operator|!
1049:22	operator|(
1049:23	name|feature
1049:31	operator|&
1049:33	name|uaf
1049:36	operator|->
1049:38	name|mask
1049:42	operator|)
1049:43	condition|)
1050:25	continue|continue;
1052:17	name|old_feature
1052:29	operator|=
1052:31	name|af
1052:33	operator|.
1052:34	name|features
1052:43	operator|&
1052:45	name|feature
1052:52	expr_stmt|;
1053:17	name|new_feature
1053:29	operator|=
1053:31	name|uaf
1053:34	operator|->
1053:36	name|features
1053:45	operator|&
1053:47	name|feature
1053:54	expr_stmt|;
1054:17	name|old_lock
1054:26	operator|=
1054:28	name|af
1054:30	operator|.
1054:31	name|lock
1054:36	operator|&
1054:38	name|feature
1054:45	expr_stmt|;
1055:17	name|new_lock
1055:26	operator|=
1055:28	operator|(
1055:29	name|uaf
1055:32	operator|->
1055:34	name|lock
1055:39	operator||
1055:41	name|af
1055:43	operator|.
1055:44	name|lock
1055:48	operator|)
1055:50	operator|&
1055:52	name|feature
1055:59	expr_stmt|;
1057:17	if|if
1057:20	condition|(
1057:21	name|new_feature
1057:33	operator|!=
1057:36	name|old_feature
1057:47	condition|)
1058:25	name|audit_log_feature_change
1058:49	argument_list|(
1058:50	name|i
1058:51	argument_list|,
1058:53	name|old_feature
1058:64	argument_list|,
1058:66	name|new_feature
1058:77	argument_list|,
1059:50	name|old_lock
1059:58	argument_list|,
1059:60	name|new_lock
1059:68	argument_list|,
1059:70	literal|1
1059:71	argument_list|)
1059:72	expr_stmt|;
1061:17	if|if
1061:20	condition|(
1061:21	name|new_feature
1061:32	condition|)
1062:25	name|af
1062:27	operator|.
1062:28	name|features
1062:37	operator||=
1062:40	name|feature
1062:47	expr_stmt|;
1063:17	else|else
1064:25	name|af
1064:27	operator|.
1064:28	name|features
1064:37	operator|&=
1064:40	operator|~
1064:41	name|feature
1064:48	expr_stmt|;
1065:17	name|af
1065:19	operator|.
1065:20	name|lock
1065:25	operator||=
1065:28	name|new_lock
1065:36	expr_stmt|;
1065:37	block|}
1068:9	return|return
1068:16	literal|0
1068:17	return|;
1068:18	block|}
-:-	end_function
-:-	begin_function
1071:1	specifier|static
1071:8	name|int
1071:12	name|audit_replace
1071:25	parameter_list|(
1071:26	name|pid_t
1071:32	name|pid
1071:35	parameter_list|)
1072:1	block|{
1073:9	name|struct
1073:16	name|sk_buff
1073:24	modifier|*
1073:25	name|skb
1073:28	decl_stmt|;
1075:9	name|skb
1075:13	operator|=
1075:15	name|audit_make_reply
1075:31	argument_list|(
1075:32	literal|0
1075:33	argument_list|,
1075:35	literal|0
1075:36	argument_list|,
1075:38	name|AUDIT_REPLACE
1075:51	argument_list|,
1075:53	literal|0
1075:54	argument_list|,
1075:56	literal|0
1075:57	argument_list|,
1075:59	operator|&
1075:60	name|pid
1075:63	argument_list|,
1075:65	sizeof|sizeof
1075:71	argument_list|(
1075:72	name|pid
1075:75	argument_list|)
1075:76	argument_list|)
1075:77	expr_stmt|;
1076:9	if|if
1076:12	condition|(
1076:13	operator|!
1076:14	name|skb
1076:17	condition|)
1077:17	return|return
1077:24	operator|-
1077:25	name|ENOMEM
1077:31	return|;
1078:9	return|return
1078:16	name|auditd_send_unicast_skb
1078:39	argument_list|(
1078:40	name|skb
1078:43	argument_list|)
1078:44	return|;
1078:45	block|}
-:-	end_function
-:-	begin_function
1081:1	specifier|static
1081:8	name|int
1081:12	name|audit_receive_msg
1081:29	parameter_list|(
1081:30	name|struct
1081:37	name|sk_buff
1081:45	modifier|*
1081:46	name|skb
1081:49	parameter_list|,
1081:51	name|struct
1081:58	name|nlmsghdr
1081:67	modifier|*
1081:68	name|nlh
1081:71	parameter_list|)
1082:1	block|{
1083:9	name|u32
1083:33	name|seq
1083:36	decl_stmt|;
1084:9	name|void
1084:33	modifier|*
1084:34	name|data
1084:38	decl_stmt|;
1085:9	name|int
1085:33	name|err
1085:36	decl_stmt|;
1086:9	name|struct
1086:16	name|audit_buffer
1086:33	modifier|*
1086:34	name|ab
1086:36	decl_stmt|;
1087:9	name|u16
1087:33	name|msg_type
1087:42	init|=
1087:44	name|nlh
1087:47	operator|->
1087:49	name|nlmsg_type
1087:59	decl_stmt|;
1088:9	name|struct
1088:16	name|audit_sig_info
1088:33	modifier|*
1088:34	name|sig_data
1088:42	decl_stmt|;
1089:9	name|char
1089:33	modifier|*
1089:34	name|ctx
1089:38	init|=
1089:40	name|NULL
1089:44	decl_stmt|;
1090:9	name|u32
1090:33	name|len
1090:36	decl_stmt|;
1092:9	name|err
1092:13	operator|=
1092:15	name|audit_netlink_ok
1092:31	argument_list|(
1092:32	name|skb
1092:35	argument_list|,
1092:37	name|msg_type
1092:45	argument_list|)
1092:46	expr_stmt|;
1093:9	if|if
1093:12	condition|(
1093:13	name|err
1093:16	condition|)
1094:17	return|return
1094:24	name|err
1094:27	return|;
1096:9	name|seq
1096:14	operator|=
1096:16	name|nlh
1096:19	operator|->
1096:21	name|nlmsg_seq
1096:30	expr_stmt|;
1097:9	name|data
1097:14	operator|=
1097:16	name|nlmsg_data
1097:26	argument_list|(
1097:27	name|nlh
1097:30	argument_list|)
1097:31	expr_stmt|;
1099:9	switch|switch
1099:16	condition|(
1099:17	name|msg_type
1099:25	condition|)
1099:27	block|{
1100:9	case|case
1100:14	name|AUDIT_GET
1100:23	case|:
1100:25	block|{
1101:17	name|struct
1101:24	name|audit_status
1101:41	name|s
1101:42	decl_stmt|;
1102:17	name|memset
1102:23	argument_list|(
1102:24	operator|&
1102:25	name|s
1102:26	argument_list|,
1102:28	literal|0
1102:29	argument_list|,
1102:31	sizeof|sizeof
1102:37	argument_list|(
1102:38	name|s
1102:39	argument_list|)
1102:40	argument_list|)
1102:41	expr_stmt|;
1103:17	name|s
1103:18	operator|.
1103:19	name|enabled
1103:41	operator|=
1103:43	name|audit_enabled
1103:56	expr_stmt|;
1104:17	name|s
1104:18	operator|.
1104:19	name|failure
1104:41	operator|=
1104:43	name|audit_failure
1104:56	expr_stmt|;
1105:17	name|rcu_read_lock
1105:30	argument_list|()
1105:32	expr_stmt|;
1106:17	name|s
1106:18	operator|.
1106:19	name|pid
1106:41	operator|=
1106:43	name|auditd_conn
1106:54	operator|.
1106:55	name|pid
1106:58	expr_stmt|;
1107:17	name|rcu_read_unlock
1107:32	argument_list|()
1107:34	expr_stmt|;
1108:17	name|s
1108:18	operator|.
1108:19	name|rate_limit
1108:41	operator|=
1108:43	name|audit_rate_limit
1108:59	expr_stmt|;
1109:17	name|s
1109:18	operator|.
1109:19	name|backlog_limit
1109:41	operator|=
1109:43	name|audit_backlog_limit
1109:62	expr_stmt|;
1110:17	name|s
1110:18	operator|.
1110:19	name|lost
1110:41	operator|=
1110:43	name|atomic_read
1110:54	argument_list|(
1110:55	operator|&
1110:56	name|audit_lost
1110:66	argument_list|)
1110:67	expr_stmt|;
1111:17	name|s
1111:18	operator|.
1111:19	name|backlog
1111:41	operator|=
1111:43	name|skb_queue_len
1111:56	argument_list|(
1111:57	operator|&
1111:58	name|audit_queue
1111:69	argument_list|)
1111:70	expr_stmt|;
1112:17	name|s
1112:18	operator|.
1112:19	name|feature_bitmap
1112:41	operator|=
1112:43	name|AUDIT_FEATURE_BITMAP_ALL
1112:67	expr_stmt|;
1113:17	name|s
1113:18	operator|.
1113:19	name|backlog_wait_time
1113:41	operator|=
1113:43	name|audit_backlog_wait_time
1113:66	expr_stmt|;
1114:17	name|audit_send_reply
1114:33	argument_list|(
1114:34	name|skb
1114:37	argument_list|,
1114:39	name|seq
1114:42	argument_list|,
1114:44	name|AUDIT_GET
1114:53	argument_list|,
1114:55	literal|0
1114:56	argument_list|,
1114:58	literal|0
1114:59	argument_list|,
1114:61	operator|&
1114:62	name|s
1114:63	argument_list|,
1114:65	sizeof|sizeof
1114:71	argument_list|(
1114:72	name|s
1114:73	argument_list|)
1114:74	argument_list|)
1114:75	expr_stmt|;
1115:17	break|break;
1115:23	block|}
1117:9	case|case
1117:14	name|AUDIT_SET
1117:23	case|:
1117:25	block|{
1118:17	name|struct
1118:24	name|audit_status
1118:41	name|s
1118:42	decl_stmt|;
1119:17	name|memset
1119:23	argument_list|(
1119:24	operator|&
1119:25	name|s
1119:26	argument_list|,
1119:28	literal|0
1119:29	argument_list|,
1119:31	sizeof|sizeof
1119:37	argument_list|(
1119:38	name|s
1119:39	argument_list|)
1119:40	argument_list|)
1119:41	expr_stmt|;
1120:17	comment|/* guard against past and future API changes */
1121:17	name|memcpy
1121:23	argument_list|(
1121:24	operator|&
1121:25	name|s
1121:26	argument_list|,
1121:28	name|data
1121:32	argument_list|,
1121:34	name|min_t
1121:39	argument_list|(
1121:40	name|size_t
1121:46	argument_list|,
1121:48	sizeof|sizeof
1121:54	argument_list|(
1121:55	name|s
1121:56	argument_list|)
1121:57	argument_list|,
1121:59	name|nlmsg_len
1121:68	argument_list|(
1121:69	name|nlh
1121:72	argument_list|)
1121:73	argument_list|)
1121:74	argument_list|)
1121:75	expr_stmt|;
1122:17	if|if
1122:20	condition|(
1122:21	name|s
1122:22	operator|.
1122:23	name|mask
1122:28	operator|&
1122:30	name|AUDIT_STATUS_ENABLED
1122:50	condition|)
1122:52	block|{
1123:25	name|err
1123:29	operator|=
1123:31	name|audit_set_enabled
1123:48	argument_list|(
1123:49	name|s
1123:50	operator|.
1123:51	name|enabled
1123:58	argument_list|)
1123:59	expr_stmt|;
1124:25	if|if
1124:28	condition|(
1124:29	name|err
1124:33	operator|<
1124:35	literal|0
1124:36	condition|)
1125:33	return|return
1125:40	name|err
1125:43	return|;
1125:44	block|}
1127:17	if|if
1127:20	condition|(
1127:21	name|s
1127:22	operator|.
1127:23	name|mask
1127:28	operator|&
1127:30	name|AUDIT_STATUS_FAILURE
1127:50	condition|)
1127:52	block|{
1128:25	name|err
1128:29	operator|=
1128:31	name|audit_set_failure
1128:48	argument_list|(
1128:49	name|s
1128:50	operator|.
1128:51	name|failure
1128:58	argument_list|)
1128:59	expr_stmt|;
1129:25	if|if
1129:28	condition|(
1129:29	name|err
1129:33	operator|<
1129:35	literal|0
1129:36	condition|)
1130:33	return|return
1130:40	name|err
1130:43	return|;
1130:44	block|}
1132:17	if|if
1132:20	condition|(
1132:21	name|s
1132:22	operator|.
1132:23	name|mask
1132:28	operator|&
1132:30	name|AUDIT_STATUS_PID
1132:46	condition|)
1132:48	block|{
1133:25	comment|/* NOTE: we are using task_tgid_vnr() below because 			 *       the s.pid value is relative to the namespace 			 *       of the caller; at present this doesn't matter 			 *       much since you can really only run auditd 			 *       from the initial pid namespace, but something 			 *       to keep in mind if this changes */
1139:25	name|int
1139:29	name|new_pid
1139:37	init|=
1139:39	name|s
1139:40	operator|.
1139:41	name|pid
1139:44	decl_stmt|;
1140:25	name|pid_t
1140:31	name|auditd_pid
1140:41	decl_stmt|;
1141:25	name|pid_t
1141:31	name|requesting_pid
1141:46	init|=
1141:48	name|task_tgid_vnr
1141:61	argument_list|(
1141:62	name|current
1141:69	argument_list|)
1141:70	decl_stmt|;
1143:25	comment|/* test the auditd connection */
1144:25	name|audit_replace
1144:38	argument_list|(
1144:39	name|requesting_pid
1144:53	argument_list|)
1144:54	expr_stmt|;
1146:25	name|rcu_read_lock
1146:38	argument_list|()
1146:40	expr_stmt|;
1147:25	name|auditd_pid
1147:36	operator|=
1147:38	name|auditd_conn
1147:49	operator|.
1147:50	name|pid
1147:53	expr_stmt|;
1148:25	comment|/* only the current auditd can unregister itself */
1149:25	if|if
1149:28	condition|(
1149:29	operator|(
1149:30	operator|!
1149:31	name|new_pid
1149:38	operator|)
1149:40	operator|&&
1149:43	operator|(
1149:44	name|requesting_pid
1149:59	operator|!=
1149:62	name|auditd_pid
1149:72	operator|)
1149:73	condition|)
1149:75	block|{
1150:33	name|rcu_read_unlock
1150:48	argument_list|()
1150:50	expr_stmt|;
1151:33	name|audit_log_config_change
1151:56	argument_list|(
1151:57	literal|"audit_pid"
1151:68	argument_list|,
1151:70	name|new_pid
1151:77	argument_list|,
1152:57	name|auditd_pid
1152:67	argument_list|,
1152:69	literal|0
1152:70	argument_list|)
1152:71	expr_stmt|;
1153:33	return|return
1153:40	operator|-
1153:41	name|EACCES
1153:47	return|;
1153:48	block|}
1155:25	comment|/* replacing a healthy auditd is not allowed */
1156:25	if|if
1156:28	condition|(
1156:29	name|auditd_pid
1156:40	operator|&&
1156:43	name|new_pid
1156:50	condition|)
1156:52	block|{
1157:33	name|rcu_read_unlock
1157:48	argument_list|()
1157:50	expr_stmt|;
1158:33	name|audit_log_config_change
1158:56	argument_list|(
1158:57	literal|"audit_pid"
1158:68	argument_list|,
1158:70	name|new_pid
1158:77	argument_list|,
1159:57	name|auditd_pid
1159:67	argument_list|,
1159:69	literal|0
1159:70	argument_list|)
1159:71	expr_stmt|;
1160:33	return|return
1160:40	operator|-
1160:41	name|EEXIST
1160:47	return|;
1160:48	block|}
1162:25	name|rcu_read_unlock
1162:40	argument_list|()
1162:42	expr_stmt|;
1164:25	if|if
1164:28	condition|(
1164:29	name|audit_enabled
1164:43	operator|!=
1164:46	name|AUDIT_OFF
1164:55	condition|)
1165:33	name|audit_log_config_change
1165:56	argument_list|(
1165:57	literal|"audit_pid"
1165:68	argument_list|,
1165:70	name|new_pid
1165:77	argument_list|,
1166:57	name|auditd_pid
1166:67	argument_list|,
1166:69	literal|1
1166:70	argument_list|)
1166:71	expr_stmt|;
1168:25	if|if
1168:28	condition|(
1168:29	name|new_pid
1168:36	condition|)
1168:38	block|{
1169:33	comment|/* register a new auditd connection */
1170:33	name|auditd_set
1170:43	argument_list|(
1170:44	name|new_pid
1170:51	argument_list|,
1171:44	name|NETLINK_CB
1171:54	argument_list|(
1171:55	name|skb
1171:58	argument_list|)
1171:59	operator|.
1171:60	name|portid
1171:66	argument_list|,
1172:44	name|sock_net
1172:52	argument_list|(
1172:53	name|NETLINK_CB
1172:63	argument_list|(
1172:64	name|skb
1172:67	argument_list|)
1172:68	operator|.
1172:69	name|sk
1172:71	argument_list|)
1172:72	argument_list|)
1172:73	expr_stmt|;
1173:33	comment|/* try to process any backlog */
1174:33	name|wake_up_interruptible
1174:54	argument_list|(
1174:55	operator|&
1174:56	name|kauditd_wait
1174:68	argument_list|)
1174:69	expr_stmt|;
1174:70	block|}
1175:27	else|else
1176:33	comment|/* unregister the auditd connection */
1177:33	name|auditd_reset
1177:45	argument_list|()
1177:47	expr_stmt|;
1177:48	block|}
1179:17	if|if
1179:20	condition|(
1179:21	name|s
1179:22	operator|.
1179:23	name|mask
1179:28	operator|&
1179:30	name|AUDIT_STATUS_RATE_LIMIT
1179:53	condition|)
1179:55	block|{
1180:25	name|err
1180:29	operator|=
1180:31	name|audit_set_rate_limit
1180:51	argument_list|(
1180:52	name|s
1180:53	operator|.
1180:54	name|rate_limit
1180:64	argument_list|)
1180:65	expr_stmt|;
1181:25	if|if
1181:28	condition|(
1181:29	name|err
1181:33	operator|<
1181:35	literal|0
1181:36	condition|)
1182:33	return|return
1182:40	name|err
1182:43	return|;
1182:44	block|}
1184:17	if|if
1184:20	condition|(
1184:21	name|s
1184:22	operator|.
1184:23	name|mask
1184:28	operator|&
1184:30	name|AUDIT_STATUS_BACKLOG_LIMIT
1184:56	condition|)
1184:58	block|{
1185:25	name|err
1185:29	operator|=
1185:31	name|audit_set_backlog_limit
1185:54	argument_list|(
1185:55	name|s
1185:56	operator|.
1185:57	name|backlog_limit
1185:70	argument_list|)
1185:71	expr_stmt|;
1186:25	if|if
1186:28	condition|(
1186:29	name|err
1186:33	operator|<
1186:35	literal|0
1186:36	condition|)
1187:33	return|return
1187:40	name|err
1187:43	return|;
1187:44	block|}
1189:17	if|if
1189:20	condition|(
1189:21	name|s
1189:22	operator|.
1189:23	name|mask
1189:28	operator|&
1189:30	name|AUDIT_STATUS_BACKLOG_WAIT_TIME
1189:60	condition|)
1189:62	block|{
1190:25	if|if
1190:28	condition|(
1190:29	sizeof|sizeof
1190:35	argument_list|(
1190:36	name|s
1190:37	argument_list|)
1190:39	operator|>
1190:41	operator|(
1190:42	name|size_t
1190:48	operator|)
1190:49	name|nlh
1190:52	operator|->
1190:54	name|nlmsg_len
1190:63	condition|)
1191:33	return|return
1191:40	operator|-
1191:41	name|EINVAL
1191:47	return|;
1192:25	if|if
1192:28	condition|(
1192:29	name|s
1192:30	operator|.
1192:31	name|backlog_wait_time
1192:49	operator|>
1192:51	literal|10
1192:53	operator|*
1192:54	name|AUDIT_BACKLOG_WAIT_TIME
1192:77	condition|)
1193:33	return|return
1193:40	operator|-
1193:41	name|EINVAL
1193:47	return|;
1194:25	name|err
1194:29	operator|=
1194:31	name|audit_set_backlog_wait_time
1194:58	argument_list|(
1194:59	name|s
1194:60	operator|.
1194:61	name|backlog_wait_time
1194:78	argument_list|)
1194:79	expr_stmt|;
1195:25	if|if
1195:28	condition|(
1195:29	name|err
1195:33	operator|<
1195:35	literal|0
1195:36	condition|)
1196:33	return|return
1196:40	name|err
1196:43	return|;
1196:44	block|}
1198:17	if|if
1198:20	condition|(
1198:21	name|s
1198:22	operator|.
1198:23	name|mask
1198:28	operator|==
1198:31	name|AUDIT_STATUS_LOST
1198:48	condition|)
1198:50	block|{
1199:25	name|u32
1199:29	name|lost
1199:34	init|=
1199:36	name|atomic_xchg
1199:47	argument_list|(
1199:48	operator|&
1199:49	name|audit_lost
1199:59	argument_list|,
1199:61	literal|0
1199:62	argument_list|)
1199:63	decl_stmt|;
1201:25	name|audit_log_config_change
1201:48	argument_list|(
1201:49	literal|"lost"
1201:55	argument_list|,
1201:57	literal|0
1201:58	argument_list|,
1201:60	name|lost
1201:64	argument_list|,
1201:66	literal|1
1201:67	argument_list|)
1201:68	expr_stmt|;
1202:25	return|return
1202:32	name|lost
1202:36	return|;
1202:37	block|}
1204:17	break|break;
1204:23	block|}
1206:9	case|case
1206:14	name|AUDIT_GET_FEATURE
1206:31	case|:
1207:17	name|err
1207:21	operator|=
1207:23	name|audit_get_feature
1207:40	argument_list|(
1207:41	name|skb
1207:44	argument_list|)
1207:45	expr_stmt|;
1208:17	if|if
1208:20	condition|(
1208:21	name|err
1208:24	condition|)
1209:25	return|return
1209:32	name|err
1209:35	return|;
1210:17	break|break;
1211:9	case|case
1211:14	name|AUDIT_SET_FEATURE
1211:31	case|:
1212:17	name|err
1212:21	operator|=
1212:23	name|audit_set_feature
1212:40	argument_list|(
1212:41	name|skb
1212:44	argument_list|)
1212:45	expr_stmt|;
1213:17	if|if
1213:20	condition|(
1213:21	name|err
1213:24	condition|)
1214:25	return|return
1214:32	name|err
1214:35	return|;
1215:17	break|break;
1216:9	case|case
1216:14	name|AUDIT_USER
1216:24	case|:
1217:9	case|case
1217:14	name|AUDIT_FIRST_USER_MSG
1217:35	operator|...
1217:39	name|AUDIT_LAST_USER_MSG
1217:58	case|:
1218:9	case|case
1218:14	name|AUDIT_FIRST_USER_MSG2
1218:36	operator|...
1218:40	name|AUDIT_LAST_USER_MSG2
1218:60	case|:
1219:17	if|if
1219:20	condition|(
1219:21	operator|!
1219:22	name|audit_enabled
1219:36	operator|&&
1219:39	name|msg_type
1219:48	operator|!=
1219:51	name|AUDIT_USER_AVC
1219:65	condition|)
1220:25	return|return
1220:32	literal|0
1220:33	return|;
1222:17	name|err
1222:21	operator|=
1222:23	name|audit_filter
1222:35	argument_list|(
1222:36	name|msg_type
1222:44	argument_list|,
1222:46	name|AUDIT_FILTER_USER
1222:63	argument_list|)
1222:64	expr_stmt|;
1223:17	if|if
1223:20	condition|(
1223:21	name|err
1223:25	operator|==
1223:28	literal|1
1223:29	condition|)
1223:31	block|{
1223:33	comment|/* match or error */
1224:25	name|err
1224:29	operator|=
1224:31	literal|0
1224:32	expr_stmt|;
1225:25	if|if
1225:28	condition|(
1225:29	name|msg_type
1225:38	operator|==
1225:41	name|AUDIT_USER_TTY
1225:55	condition|)
1225:57	block|{
1226:33	name|err
1226:37	operator|=
1226:39	name|tty_audit_push
1226:53	argument_list|()
1226:55	expr_stmt|;
1227:33	if|if
1227:36	condition|(
1227:37	name|err
1227:40	condition|)
1228:41	break|break;
1228:47	block|}
1230:25	name|audit_log_common_recv_msg
1230:50	argument_list|(
1230:51	operator|&
1230:52	name|ab
1230:54	argument_list|,
1230:56	name|msg_type
1230:64	argument_list|)
1230:65	expr_stmt|;
1231:25	if|if
1231:28	condition|(
1231:29	name|msg_type
1231:38	operator|!=
1231:41	name|AUDIT_USER_TTY
1231:55	condition|)
1232:33	name|audit_log_format
1232:49	argument_list|(
1232:50	name|ab
1232:52	argument_list|,
1232:54	literal|" msg='%.*s'"
1232:67	argument_list|,
1233:50	name|AUDIT_MESSAGE_TEXT_MAX
1233:72	argument_list|,
1234:50	operator|(
1234:51	name|char
1234:56	operator|*
1234:57	operator|)
1234:58	name|data
1234:62	argument_list|)
1234:63	expr_stmt|;
1235:25	else|else
1235:30	block|{
1236:33	name|int
1236:37	name|size
1236:41	decl_stmt|;
1238:33	name|audit_log_format
1238:49	argument_list|(
1238:50	name|ab
1238:52	argument_list|,
1238:54	literal|" data="
1238:62	argument_list|)
1238:63	expr_stmt|;
1239:33	name|size
1239:38	operator|=
1239:40	name|nlmsg_len
1239:49	argument_list|(
1239:50	name|nlh
1239:53	argument_list|)
1239:54	expr_stmt|;
1240:33	if|if
1240:36	condition|(
1240:37	name|size
1240:42	operator|>
1240:44	literal|0
1240:46	operator|&&
1241:37	operator|(
1241:38	operator|(
1241:39	name|unsigned
1241:48	name|char
1241:53	operator|*
1241:54	operator|)
1241:55	name|data
1241:59	operator|)
1241:60	index|[
1241:61	name|size
1241:66	operator|-
1241:68	literal|1
1241:69	index|]
1241:71	operator|==
1241:74	literal|'\0'
1241:78	condition|)
1242:41	name|size
1242:45	operator|--
1242:47	expr_stmt|;
1243:33	name|audit_log_n_untrustedstring
1243:60	argument_list|(
1243:61	name|ab
1243:63	argument_list|,
1243:65	name|data
1243:69	argument_list|,
1243:71	name|size
1243:75	argument_list|)
1243:76	expr_stmt|;
1243:77	block|}
1245:25	name|audit_set_portid
1245:41	argument_list|(
1245:42	name|ab
1245:44	argument_list|,
1245:46	name|NETLINK_CB
1245:56	argument_list|(
1245:57	name|skb
1245:60	argument_list|)
1245:61	operator|.
1245:62	name|portid
1245:68	argument_list|)
1245:69	expr_stmt|;
1246:25	name|audit_log_end
1246:38	argument_list|(
1246:39	name|ab
1246:41	argument_list|)
1246:42	expr_stmt|;
1246:43	block|}
1248:17	break|break;
1249:9	case|case
1249:14	name|AUDIT_ADD_RULE
1249:28	case|:
1250:9	case|case
1250:14	name|AUDIT_DEL_RULE
1250:28	case|:
1251:17	if|if
1251:20	condition|(
1251:21	name|nlmsg_len
1251:30	argument_list|(
1251:31	name|nlh
1251:34	argument_list|)
1251:36	operator|<
1251:38	sizeof|sizeof
1251:44	argument_list|(
1251:45	expr|struct
1251:52	name|audit_rule_data
1251:67	argument_list|)
1251:68	condition|)
1252:25	return|return
1252:32	operator|-
1252:33	name|EINVAL
1252:39	return|;
1253:17	if|if
1253:20	condition|(
1253:21	name|audit_enabled
1253:35	operator|==
1253:38	name|AUDIT_LOCKED
1253:50	condition|)
1253:52	block|{
1254:25	name|audit_log_common_recv_msg
1254:50	argument_list|(
1254:51	operator|&
1254:52	name|ab
1254:54	argument_list|,
1254:56	name|AUDIT_CONFIG_CHANGE
1254:75	argument_list|)
1254:76	expr_stmt|;
1255:25	name|audit_log_format
1255:41	argument_list|(
1255:42	name|ab
1255:44	argument_list|,
1255:46	literal|" audit_enabled=%d res=0"
1255:71	argument_list|,
1255:73	name|audit_enabled
1255:86	argument_list|)
1255:87	expr_stmt|;
1256:25	name|audit_log_end
1256:38	argument_list|(
1256:39	name|ab
1256:41	argument_list|)
1256:42	expr_stmt|;
1257:25	return|return
1257:32	operator|-
1257:33	name|EPERM
1257:38	return|;
1257:39	block|}
1259:17	name|err
1259:21	operator|=
1259:23	name|audit_rule_change
1259:40	argument_list|(
1259:41	name|msg_type
1259:49	argument_list|,
1259:51	name|NETLINK_CB
1259:61	argument_list|(
1259:62	name|skb
1259:65	argument_list|)
1259:66	operator|.
1259:67	name|portid
1259:73	argument_list|,
1260:44	name|seq
1260:47	argument_list|,
1260:49	name|data
1260:53	argument_list|,
1260:55	name|nlmsg_len
1260:64	argument_list|(
1260:65	name|nlh
1260:68	argument_list|)
1260:69	argument_list|)
1260:70	expr_stmt|;
1261:17	break|break;
1262:9	case|case
1262:14	name|AUDIT_LIST_RULES
1262:30	case|:
1263:17	name|err
1263:21	operator|=
1263:23	name|audit_list_rules_send
1263:44	argument_list|(
1263:45	name|skb
1263:48	argument_list|,
1263:50	name|seq
1263:53	argument_list|)
1263:54	expr_stmt|;
1264:17	break|break;
1265:9	case|case
1265:14	name|AUDIT_TRIM
1265:24	case|:
1266:17	name|audit_trim_trees
1266:33	argument_list|()
1266:35	expr_stmt|;
1267:17	name|audit_log_common_recv_msg
1267:42	argument_list|(
1267:43	operator|&
1267:44	name|ab
1267:46	argument_list|,
1267:48	name|AUDIT_CONFIG_CHANGE
1267:67	argument_list|)
1267:68	expr_stmt|;
1268:17	name|audit_log_format
1268:33	argument_list|(
1268:34	name|ab
1268:36	argument_list|,
1268:38	literal|" op=trim res=1"
1268:54	argument_list|)
1268:55	expr_stmt|;
1269:17	name|audit_log_end
1269:30	argument_list|(
1269:31	name|ab
1269:33	argument_list|)
1269:34	expr_stmt|;
1270:17	break|break;
1271:9	case|case
1271:14	name|AUDIT_MAKE_EQUIV
1271:30	case|:
1271:32	block|{
1272:17	name|void
1272:22	modifier|*
1272:23	name|bufp
1272:28	init|=
1272:30	name|data
1272:34	decl_stmt|;
1273:17	name|u32
1273:21	name|sizes
1273:26	index|[
1273:27	literal|2
1273:28	index|]
1273:29	decl_stmt|;
1274:17	name|size_t
1274:24	name|msglen
1274:31	init|=
1274:33	name|nlmsg_len
1274:42	argument_list|(
1274:43	name|nlh
1274:46	argument_list|)
1274:47	decl_stmt|;
1275:17	name|char
1275:22	modifier|*
1275:23	name|old
1275:26	decl_stmt|,
1275:28	modifier|*
1275:29	name|new
1275:32	decl_stmt|;
1277:17	name|err
1277:21	operator|=
1277:23	operator|-
1277:24	name|EINVAL
1277:30	expr_stmt|;
1278:17	if|if
1278:20	condition|(
1278:21	name|msglen
1278:28	operator|<
1278:30	literal|2
1278:32	operator|*
1278:34	sizeof|sizeof
1278:40	argument_list|(
1278:41	name|u32
1278:44	argument_list|)
1278:45	condition|)
1279:25	break|break;
1280:17	name|memcpy
1280:23	argument_list|(
1280:24	name|sizes
1280:29	argument_list|,
1280:31	name|bufp
1280:35	argument_list|,
1280:37	literal|2
1280:39	operator|*
1280:41	sizeof|sizeof
1280:47	argument_list|(
1280:48	name|u32
1280:51	argument_list|)
1280:52	argument_list|)
1280:53	expr_stmt|;
1281:17	name|bufp
1281:22	operator|+=
1281:25	literal|2
1281:27	operator|*
1281:29	sizeof|sizeof
1281:35	argument_list|(
1281:36	name|u32
1281:39	argument_list|)
1281:40	expr_stmt|;
1282:17	name|msglen
1282:24	operator|-=
1282:27	literal|2
1282:29	operator|*
1282:31	sizeof|sizeof
1282:37	argument_list|(
1282:38	name|u32
1282:41	argument_list|)
1282:42	expr_stmt|;
1283:17	name|old
1283:21	operator|=
1283:23	name|audit_unpack_string
1283:42	argument_list|(
1283:43	operator|&
1283:44	name|bufp
1283:48	argument_list|,
1283:50	operator|&
1283:51	name|msglen
1283:57	argument_list|,
1283:59	name|sizes
1283:64	index|[
1283:65	literal|0
1283:66	index|]
1283:67	argument_list|)
1283:68	expr_stmt|;
1284:17	if|if
1284:20	condition|(
1284:21	name|IS_ERR
1284:27	argument_list|(
1284:28	name|old
1284:31	argument_list|)
1284:32	condition|)
1284:34	block|{
1285:25	name|err
1285:29	operator|=
1285:31	name|PTR_ERR
1285:38	argument_list|(
1285:39	name|old
1285:42	argument_list|)
1285:43	expr_stmt|;
1286:25	break|break;
1286:31	block|}
1288:17	name|new
1288:21	operator|=
1288:23	name|audit_unpack_string
1288:42	argument_list|(
1288:43	operator|&
1288:44	name|bufp
1288:48	argument_list|,
1288:50	operator|&
1288:51	name|msglen
1288:57	argument_list|,
1288:59	name|sizes
1288:64	index|[
1288:65	literal|1
1288:66	index|]
1288:67	argument_list|)
1288:68	expr_stmt|;
1289:17	if|if
1289:20	condition|(
1289:21	name|IS_ERR
1289:27	argument_list|(
1289:28	name|new
1289:31	argument_list|)
1289:32	condition|)
1289:34	block|{
1290:25	name|err
1290:29	operator|=
1290:31	name|PTR_ERR
1290:38	argument_list|(
1290:39	name|new
1290:42	argument_list|)
1290:43	expr_stmt|;
1291:25	name|kfree
1291:30	argument_list|(
1291:31	name|old
1291:34	argument_list|)
1291:35	expr_stmt|;
1292:25	break|break;
1292:31	block|}
1294:17	comment|/* OK, here comes... */
1295:17	name|err
1295:21	operator|=
1295:23	name|audit_tag_tree
1295:37	argument_list|(
1295:38	name|old
1295:41	argument_list|,
1295:43	name|new
1295:46	argument_list|)
1295:47	expr_stmt|;
1297:17	name|audit_log_common_recv_msg
1297:42	argument_list|(
1297:43	operator|&
1297:44	name|ab
1297:46	argument_list|,
1297:48	name|AUDIT_CONFIG_CHANGE
1297:67	argument_list|)
1297:68	expr_stmt|;
1299:17	name|audit_log_format
1299:33	argument_list|(
1299:34	name|ab
1299:36	argument_list|,
1299:38	literal|" op=make_equiv old="
1299:59	argument_list|)
1299:60	expr_stmt|;
1300:17	name|audit_log_untrustedstring
1300:42	argument_list|(
1300:43	name|ab
1300:45	argument_list|,
1300:47	name|old
1300:50	argument_list|)
1300:51	expr_stmt|;
1301:17	name|audit_log_format
1301:33	argument_list|(
1301:34	name|ab
1301:36	argument_list|,
1301:38	literal|" new="
1301:45	argument_list|)
1301:46	expr_stmt|;
1302:17	name|audit_log_untrustedstring
1302:42	argument_list|(
1302:43	name|ab
1302:45	argument_list|,
1302:47	name|new
1302:50	argument_list|)
1302:51	expr_stmt|;
1303:17	name|audit_log_format
1303:33	argument_list|(
1303:34	name|ab
1303:36	argument_list|,
1303:38	literal|" res=%d"
1303:47	argument_list|,
1303:49	operator|!
1303:50	name|err
1303:53	argument_list|)
1303:54	expr_stmt|;
1304:17	name|audit_log_end
1304:30	argument_list|(
1304:31	name|ab
1304:33	argument_list|)
1304:34	expr_stmt|;
1305:17	name|kfree
1305:22	argument_list|(
1305:23	name|old
1305:26	argument_list|)
1305:27	expr_stmt|;
1306:17	name|kfree
1306:22	argument_list|(
1306:23	name|new
1306:26	argument_list|)
1306:27	expr_stmt|;
1307:17	break|break;
1307:23	block|}
1309:9	case|case
1309:14	name|AUDIT_SIGNAL_INFO
1309:31	case|:
1310:17	name|len
1310:21	operator|=
1310:23	literal|0
1310:24	expr_stmt|;
1311:17	if|if
1311:20	condition|(
1311:21	name|audit_sig_sid
1311:34	condition|)
1311:36	block|{
1312:25	name|err
1312:29	operator|=
1312:31	name|security_secid_to_secctx
1312:55	argument_list|(
1312:56	name|audit_sig_sid
1312:69	argument_list|,
1312:71	operator|&
1312:72	name|ctx
1312:75	argument_list|,
1312:77	operator|&
1312:78	name|len
1312:81	argument_list|)
1312:82	expr_stmt|;
1313:25	if|if
1313:28	condition|(
1313:29	name|err
1313:32	condition|)
1314:33	return|return
1314:40	name|err
1314:43	return|;
1314:44	block|}
1316:17	name|sig_data
1316:26	operator|=
1316:28	name|kmalloc
1316:35	argument_list|(
1316:36	sizeof|sizeof
1316:42	argument_list|(
1316:43	operator|*
1316:44	name|sig_data
1316:52	argument_list|)
1316:54	operator|+
1316:56	name|len
1316:59	argument_list|,
1316:61	name|GFP_KERNEL
1316:71	argument_list|)
1316:72	expr_stmt|;
1317:17	if|if
1317:20	condition|(
1317:21	operator|!
1317:22	name|sig_data
1317:30	condition|)
1317:32	block|{
1318:25	if|if
1318:28	condition|(
1318:29	name|audit_sig_sid
1318:42	condition|)
1319:33	name|security_release_secctx
1319:56	argument_list|(
1319:57	name|ctx
1319:60	argument_list|,
1319:62	name|len
1319:65	argument_list|)
1319:66	expr_stmt|;
1320:25	return|return
1320:32	operator|-
1320:33	name|ENOMEM
1320:39	return|;
1320:40	block|}
1322:17	name|sig_data
1322:25	operator|->
1322:27	name|uid
1322:31	operator|=
1322:33	name|from_kuid
1322:42	argument_list|(
1322:43	operator|&
1322:44	name|init_user_ns
1322:56	argument_list|,
1322:58	name|audit_sig_uid
1322:71	argument_list|)
1322:72	expr_stmt|;
1323:17	name|sig_data
1323:25	operator|->
1323:27	name|pid
1323:31	operator|=
1323:33	name|audit_sig_pid
1323:46	expr_stmt|;
1324:17	if|if
1324:20	condition|(
1324:21	name|audit_sig_sid
1324:34	condition|)
1324:36	block|{
1325:25	name|memcpy
1325:31	argument_list|(
1325:32	name|sig_data
1325:40	operator|->
1325:42	name|ctx
1325:45	argument_list|,
1325:47	name|ctx
1325:50	argument_list|,
1325:52	name|len
1325:55	argument_list|)
1325:56	expr_stmt|;
1326:25	name|security_release_secctx
1326:48	argument_list|(
1326:49	name|ctx
1326:52	argument_list|,
1326:54	name|len
1326:57	argument_list|)
1326:58	expr_stmt|;
1326:59	block|}
1328:17	name|audit_send_reply
1328:33	argument_list|(
1328:34	name|skb
1328:37	argument_list|,
1328:39	name|seq
1328:42	argument_list|,
1328:44	name|AUDIT_SIGNAL_INFO
1328:61	argument_list|,
1328:63	literal|0
1328:64	argument_list|,
1328:66	literal|0
1328:67	argument_list|,
1329:34	name|sig_data
1329:42	argument_list|,
1329:44	sizeof|sizeof
1329:50	argument_list|(
1329:51	operator|*
1329:52	name|sig_data
1329:60	argument_list|)
1329:62	operator|+
1329:64	name|len
1329:67	argument_list|)
1329:68	expr_stmt|;
1330:17	name|kfree
1330:22	argument_list|(
1330:23	name|sig_data
1330:31	argument_list|)
1330:32	expr_stmt|;
1331:17	break|break;
1332:9	case|case
1332:14	name|AUDIT_TTY_GET
1332:27	case|:
1332:29	block|{
1333:17	name|struct
1333:24	name|audit_tty_status
1333:41	name|s
1333:42	decl_stmt|;
1334:17	name|unsigned
1334:26	name|int
1334:30	name|t
1334:31	decl_stmt|;
1336:17	name|t
1336:19	operator|=
1336:21	name|READ_ONCE
1336:30	argument_list|(
1336:31	name|current
1336:38	operator|->
1336:40	name|signal
1336:46	operator|->
1336:48	name|audit_tty
1336:57	argument_list|)
1336:58	expr_stmt|;
1337:17	name|s
1337:18	operator|.
1337:19	name|enabled
1337:27	operator|=
1337:29	name|t
1337:31	operator|&
1337:33	name|AUDIT_TTY_ENABLE
1337:49	expr_stmt|;
1338:17	name|s
1338:18	operator|.
1338:19	name|log_passwd
1338:30	operator|=
1338:32	operator|!
1338:33	operator|!
1338:34	operator|(
1338:35	name|t
1338:37	operator|&
1338:39	name|AUDIT_TTY_LOG_PASSWD
1338:59	operator|)
1338:60	expr_stmt|;
1340:17	name|audit_send_reply
1340:33	argument_list|(
1340:34	name|skb
1340:37	argument_list|,
1340:39	name|seq
1340:42	argument_list|,
1340:44	name|AUDIT_TTY_GET
1340:57	argument_list|,
1340:59	literal|0
1340:60	argument_list|,
1340:62	literal|0
1340:63	argument_list|,
1340:65	operator|&
1340:66	name|s
1340:67	argument_list|,
1340:69	sizeof|sizeof
1340:75	argument_list|(
1340:76	name|s
1340:77	argument_list|)
1340:78	argument_list|)
1340:79	expr_stmt|;
1341:17	break|break;
1341:23	block|}
1343:9	case|case
1343:14	name|AUDIT_TTY_SET
1343:27	case|:
1343:29	block|{
1344:17	name|struct
1344:24	name|audit_tty_status
1344:41	name|s
1344:42	decl_stmt|,
1344:44	name|old
1344:47	decl_stmt|;
1345:17	name|struct
1345:24	name|audit_buffer
1345:41	modifier|*
1345:42	name|ab
1345:44	decl_stmt|;
1346:17	name|unsigned
1346:26	name|int
1346:30	name|t
1346:31	decl_stmt|;
1348:17	name|memset
1348:23	argument_list|(
1348:24	operator|&
1348:25	name|s
1348:26	argument_list|,
1348:28	literal|0
1348:29	argument_list|,
1348:31	sizeof|sizeof
1348:37	argument_list|(
1348:38	name|s
1348:39	argument_list|)
1348:40	argument_list|)
1348:41	expr_stmt|;
1349:17	comment|/* guard against past and future API changes */
1350:17	name|memcpy
1350:23	argument_list|(
1350:24	operator|&
1350:25	name|s
1350:26	argument_list|,
1350:28	name|data
1350:32	argument_list|,
1350:34	name|min_t
1350:39	argument_list|(
1350:40	name|size_t
1350:46	argument_list|,
1350:48	sizeof|sizeof
1350:54	argument_list|(
1350:55	name|s
1350:56	argument_list|)
1350:57	argument_list|,
1350:59	name|nlmsg_len
1350:68	argument_list|(
1350:69	name|nlh
1350:72	argument_list|)
1350:73	argument_list|)
1350:74	argument_list|)
1350:75	expr_stmt|;
1351:17	comment|/* check if new data is valid */
1352:17	if|if
1352:20	condition|(
1352:21	operator|(
1352:22	name|s
1352:23	operator|.
1352:24	name|enabled
1352:32	operator|!=
1352:35	literal|0
1352:37	operator|&&
1352:40	name|s
1352:41	operator|.
1352:42	name|enabled
1352:50	operator|!=
1352:53	literal|1
1352:54	operator|)
1352:56	operator|||
1353:21	operator|(
1353:22	name|s
1353:23	operator|.
1353:24	name|log_passwd
1353:35	operator|!=
1353:38	literal|0
1353:40	operator|&&
1353:43	name|s
1353:44	operator|.
1353:45	name|log_passwd
1353:56	operator|!=
1353:59	literal|1
1353:60	operator|)
1353:61	condition|)
1354:25	name|err
1354:29	operator|=
1354:31	operator|-
1354:32	name|EINVAL
1354:38	expr_stmt|;
1356:17	if|if
1356:20	condition|(
1356:21	name|err
1356:24	condition|)
1357:25	name|t
1357:27	operator|=
1357:29	name|READ_ONCE
1357:38	argument_list|(
1357:39	name|current
1357:46	operator|->
1357:48	name|signal
1357:54	operator|->
1357:56	name|audit_tty
1357:65	argument_list|)
1357:66	expr_stmt|;
1358:17	else|else
1358:22	block|{
1359:25	name|t
1359:27	operator|=
1359:29	name|s
1359:30	operator|.
1359:31	name|enabled
1359:39	operator||
1359:41	operator|(
1359:42	operator|-
1359:43	name|s
1359:44	operator|.
1359:45	name|log_passwd
1359:56	operator|&
1359:58	name|AUDIT_TTY_LOG_PASSWD
1359:78	operator|)
1359:79	expr_stmt|;
1360:25	name|t
1360:27	operator|=
1360:29	name|xchg
1360:33	argument_list|(
1360:34	operator|&
1360:35	name|current
1360:42	operator|->
1360:44	name|signal
1360:50	operator|->
1360:52	name|audit_tty
1360:61	argument_list|,
1360:63	name|t
1360:64	argument_list|)
1360:65	expr_stmt|;
1360:66	block|}
1362:17	name|old
1362:20	operator|.
1362:21	name|enabled
1362:29	operator|=
1362:31	name|t
1362:33	operator|&
1362:35	name|AUDIT_TTY_ENABLE
1362:51	expr_stmt|;
1363:17	name|old
1363:20	operator|.
1363:21	name|log_passwd
1363:32	operator|=
1363:34	operator|!
1363:35	operator|!
1363:36	operator|(
1363:37	name|t
1363:39	operator|&
1363:41	name|AUDIT_TTY_LOG_PASSWD
1363:61	operator|)
1363:62	expr_stmt|;
1365:17	name|audit_log_common_recv_msg
1365:42	argument_list|(
1365:43	operator|&
1365:44	name|ab
1365:46	argument_list|,
1365:48	name|AUDIT_CONFIG_CHANGE
1365:67	argument_list|)
1365:68	expr_stmt|;
1366:17	name|audit_log_format
1366:33	argument_list|(
1366:34	name|ab
1366:36	argument_list|,
1366:38	literal|" op=tty_set old-enabled=%d new-enabled=%d"
1367:34	literal|" old-log_passwd=%d new-log_passwd=%d res=%d"
1367:79	argument_list|,
1368:34	name|old
1368:37	operator|.
1368:38	name|enabled
1368:45	argument_list|,
1368:47	name|s
1368:48	operator|.
1368:49	name|enabled
1368:56	argument_list|,
1368:58	name|old
1368:61	operator|.
1368:62	name|log_passwd
1368:72	argument_list|,
1369:34	name|s
1369:35	operator|.
1369:36	name|log_passwd
1369:46	argument_list|,
1369:48	operator|!
1369:49	name|err
1369:52	argument_list|)
1369:53	expr_stmt|;
1370:17	name|audit_log_end
1370:30	argument_list|(
1370:31	name|ab
1370:33	argument_list|)
1370:34	expr_stmt|;
1371:17	break|break;
1371:23	block|}
1373:9	default|default:
1374:17	name|err
1374:21	operator|=
1374:23	operator|-
1374:24	name|EINVAL
1374:30	expr_stmt|;
1375:17	break|break;
1375:23	block|}
1378:9	return|return
1378:16	name|err
1378:20	operator|<
1378:22	literal|0
1378:23	condition|?
1378:26	name|err
1378:30	else|:
1378:32	literal|0
1378:33	return|;
1378:34	block|}
-:-	end_function
-:-	begin_comment
1381:1	comment|/*  * Get message from skb.  Each message is processed by audit_receive_msg.  * Malformed skbs with wrong length are discarded silently.  */
-:-	end_comment
-:-	begin_function
1385:1	specifier|static
1385:8	name|void
1385:13	name|audit_receive_skb
1385:30	parameter_list|(
1385:31	name|struct
1385:38	name|sk_buff
1385:46	modifier|*
1385:47	name|skb
1385:50	parameter_list|)
1386:1	block|{
1387:9	name|struct
1387:16	name|nlmsghdr
1387:25	modifier|*
1387:26	name|nlh
1387:29	decl_stmt|;
1388:9	comment|/* 	 * len MUST be signed for nlmsg_next to be able to dec it below 0 	 * if the nlmsg_len was not aligned 	 */
1392:9	name|int
1392:13	name|len
1392:16	decl_stmt|;
1393:9	name|int
1393:13	name|err
1393:16	decl_stmt|;
1395:9	name|nlh
1395:13	operator|=
1395:15	name|nlmsg_hdr
1395:24	argument_list|(
1395:25	name|skb
1395:28	argument_list|)
1395:29	expr_stmt|;
1396:9	name|len
1396:13	operator|=
1396:15	name|skb
1396:18	operator|->
1396:20	name|len
1396:23	expr_stmt|;
1398:9	while|while
1398:15	condition|(
1398:16	name|nlmsg_ok
1398:24	argument_list|(
1398:25	name|nlh
1398:28	argument_list|,
1398:30	name|len
1398:33	argument_list|)
1398:34	condition|)
1398:36	block|{
1399:17	name|err
1399:21	operator|=
1399:23	name|audit_receive_msg
1399:40	argument_list|(
1399:41	name|skb
1399:44	argument_list|,
1399:46	name|nlh
1399:49	argument_list|)
1399:50	expr_stmt|;
1400:17	comment|/* if err or if this message says it wants a response */
1401:17	if|if
1401:20	condition|(
1401:21	name|err
1401:25	operator|||
1401:28	operator|(
1401:29	name|nlh
1401:32	operator|->
1401:34	name|nlmsg_flags
1401:46	operator|&
1401:48	name|NLM_F_ACK
1401:57	operator|)
1401:58	condition|)
1402:25	name|netlink_ack
1402:36	argument_list|(
1402:37	name|skb
1402:40	argument_list|,
1402:42	name|nlh
1402:45	argument_list|,
1402:47	name|err
1402:50	argument_list|)
1402:51	expr_stmt|;
1404:17	name|nlh
1404:21	operator|=
1404:23	name|nlmsg_next
1404:33	argument_list|(
1404:34	name|nlh
1404:37	argument_list|,
1404:39	operator|&
1404:40	name|len
1404:43	argument_list|)
1404:44	expr_stmt|;
1404:45	block|}
1405:10	block|}
-:-	end_function
-:-	begin_comment
1408:1	comment|/* Receive messages from netlink socket. */
-:-	end_comment
-:-	begin_function
1409:1	specifier|static
1409:8	name|void
1409:13	name|audit_receive
1409:26	parameter_list|(
1409:27	name|struct
1409:34	name|sk_buff
1409:43	modifier|*
1409:44	name|skb
1409:47	parameter_list|)
1410:1	block|{
1411:9	name|mutex_lock
1411:19	argument_list|(
1411:20	operator|&
1411:21	name|audit_cmd_mutex
1411:36	argument_list|)
1411:37	expr_stmt|;
1412:9	name|audit_receive_skb
1412:26	argument_list|(
1412:27	name|skb
1412:30	argument_list|)
1412:31	expr_stmt|;
1413:9	name|mutex_unlock
1413:21	argument_list|(
1413:22	operator|&
1413:23	name|audit_cmd_mutex
1413:38	argument_list|)
1413:39	expr_stmt|;
1413:40	block|}
-:-	end_function
-:-	begin_comment
1416:1	comment|/* Run custom bind function on netlink socket group connect or bind requests. */
-:-	end_comment
-:-	begin_function
1417:1	specifier|static
1417:8	name|int
1417:12	name|audit_bind
1417:22	parameter_list|(
1417:23	name|struct
1417:30	name|net
1417:34	modifier|*
1417:35	name|net
1417:38	parameter_list|,
1417:40	name|int
1417:44	name|group
1417:49	parameter_list|)
1418:1	block|{
1419:9	if|if
1419:12	condition|(
1419:13	operator|!
1419:14	name|capable
1419:21	argument_list|(
1419:22	name|CAP_AUDIT_READ
1419:36	argument_list|)
1419:37	condition|)
1420:17	return|return
1420:24	operator|-
1420:25	name|EPERM
1420:30	return|;
1422:9	return|return
1422:16	literal|0
1422:17	return|;
1422:18	block|}
-:-	end_function
-:-	begin_function
1425:1	specifier|static
1425:8	name|int
1425:12	name|__net_init
1425:23	name|audit_net_init
1425:37	parameter_list|(
1425:38	name|struct
1425:45	name|net
1425:49	modifier|*
1425:50	name|net
1425:53	parameter_list|)
1426:1	block|{
1427:9	name|struct
1427:16	name|netlink_kernel_cfg
1427:35	name|cfg
1427:39	init|=
1427:41	block|{
1428:17	operator|.
1428:18	name|input
1428:25	operator|=
1428:27	name|audit_receive
1428:40	block|,
1429:17	operator|.
1429:18	name|bind
1429:25	operator|=
1429:27	name|audit_bind
1429:37	block|,
1430:17	operator|.
1430:18	name|flags
1430:25	operator|=
1430:27	name|NL_CFG_F_NONROOT_RECV
1430:48	block|,
1431:17	operator|.
1431:18	name|groups
1431:25	operator|=
1431:27	name|AUDIT_NLGRP_MAX
1431:42	block|, 	}
1432:10	decl_stmt|;
1434:9	name|struct
1434:16	name|audit_net
1434:26	modifier|*
1434:27	name|aunet
1434:33	init|=
1434:35	name|net_generic
1434:46	argument_list|(
1434:47	name|net
1434:50	argument_list|,
1434:52	name|audit_net_id
1434:64	argument_list|)
1434:65	decl_stmt|;
1436:9	name|aunet
1436:14	operator|->
1436:16	name|sk
1436:19	operator|=
1436:21	name|netlink_kernel_create
1436:42	argument_list|(
1436:43	name|net
1436:46	argument_list|,
1436:48	name|NETLINK_AUDIT
1436:61	argument_list|,
1436:63	operator|&
1436:64	name|cfg
1436:67	argument_list|)
1436:68	expr_stmt|;
1437:9	if|if
1437:12	condition|(
1437:13	name|aunet
1437:18	operator|->
1437:20	name|sk
1437:23	operator|==
1437:26	name|NULL
1437:30	condition|)
1437:32	block|{
1438:17	name|audit_panic
1438:28	argument_list|(
1438:29	literal|"cannot initialize netlink socket in namespace"
1438:76	argument_list|)
1438:77	expr_stmt|;
1439:17	return|return
1439:24	operator|-
1439:25	name|ENOMEM
1439:31	return|;
1439:32	block|}
1441:9	name|aunet
1441:14	operator|->
1441:16	name|sk
1441:18	operator|->
1441:20	name|sk_sndtimeo
1441:32	operator|=
1441:34	name|MAX_SCHEDULE_TIMEOUT
1441:54	expr_stmt|;
1443:9	return|return
1443:16	literal|0
1443:17	return|;
1443:18	block|}
-:-	end_function
-:-	begin_function
1446:1	specifier|static
1446:8	name|void
1446:13	name|__net_exit
1446:24	name|audit_net_exit
1446:38	parameter_list|(
1446:39	name|struct
1446:46	name|net
1446:50	modifier|*
1446:51	name|net
1446:54	parameter_list|)
1447:1	block|{
1448:9	name|struct
1448:16	name|audit_net
1448:26	modifier|*
1448:27	name|aunet
1448:33	init|=
1448:35	name|net_generic
1448:46	argument_list|(
1448:47	name|net
1448:50	argument_list|,
1448:52	name|audit_net_id
1448:64	argument_list|)
1448:65	decl_stmt|;
1450:9	name|rcu_read_lock
1450:22	argument_list|()
1450:24	expr_stmt|;
1451:9	if|if
1451:12	condition|(
1451:13	name|net
1451:17	operator|==
1451:20	name|auditd_conn
1451:31	operator|.
1451:32	name|net
1451:35	condition|)
1452:17	name|auditd_reset
1452:29	argument_list|()
1452:31	expr_stmt|;
1453:9	name|rcu_read_unlock
1453:24	argument_list|()
1453:26	expr_stmt|;
1455:9	name|netlink_kernel_release
1455:31	argument_list|(
1455:32	name|aunet
1455:37	operator|->
1455:39	name|sk
1455:41	argument_list|)
1455:42	expr_stmt|;
1455:43	block|}
-:-	end_function
-:-	begin_decl_stmt
1458:1	specifier|static
1458:8	name|struct
1458:15	name|pernet_operations
1458:33	name|audit_net_ops
1458:47	name|__net_initdata
1458:62	init|=
1458:64	block|{
1459:9	operator|.
1459:10	name|init
1459:15	operator|=
1459:17	name|audit_net_init
1459:31	block|,
1460:9	operator|.
1460:10	name|exit
1460:15	operator|=
1460:17	name|audit_net_exit
1460:31	block|,
1461:9	operator|.
1461:10	name|id
1461:13	operator|=
1461:15	operator|&
1461:16	name|audit_net_id
1461:28	block|,
1462:9	operator|.
1462:10	name|size
1462:15	operator|=
1462:17	sizeof|sizeof
1462:23	argument_list|(
1462:24	expr|struct
1462:31	name|audit_net
1462:40	argument_list|)
1462:41	block|, }
1463:2	decl_stmt|;
-:-	end_decl_stmt
-:-	begin_comment
1465:1	comment|/* Initialize audit support at boot time. */
-:-	end_comment
-:-	begin_function
1466:1	specifier|static
1466:8	name|int
1466:12	name|__init
1466:19	name|audit_init
1466:29	parameter_list|(
1466:30	name|void
1466:34	parameter_list|)
1467:1	block|{
1468:9	name|int
1468:13	name|i
1468:14	decl_stmt|;
1470:9	if|if
1470:12	condition|(
1470:13	name|audit_initialized
1470:31	operator|==
1470:34	name|AUDIT_DISABLED
1470:48	condition|)
1471:17	return|return
1471:24	literal|0
1471:25	return|;
1473:9	name|memset
1473:15	argument_list|(
1473:16	operator|&
1473:17	name|auditd_conn
1473:28	argument_list|,
1473:30	literal|0
1473:31	argument_list|,
1473:33	sizeof|sizeof
1473:39	argument_list|(
1473:40	name|auditd_conn
1473:51	argument_list|)
1473:52	argument_list|)
1473:53	expr_stmt|;
1474:9	name|spin_lock_init
1474:23	argument_list|(
1474:24	operator|&
1474:25	name|auditd_conn
1474:36	operator|.
1474:37	name|lock
1474:41	argument_list|)
1474:42	expr_stmt|;
1476:9	name|skb_queue_head_init
1476:28	argument_list|(
1476:29	operator|&
1476:30	name|audit_queue
1476:41	argument_list|)
1476:42	expr_stmt|;
1477:9	name|skb_queue_head_init
1477:28	argument_list|(
1477:29	operator|&
1477:30	name|audit_retry_queue
1477:47	argument_list|)
1477:48	expr_stmt|;
1478:9	name|skb_queue_head_init
1478:28	argument_list|(
1478:29	operator|&
1478:30	name|audit_hold_queue
1478:46	argument_list|)
1478:47	expr_stmt|;
1480:9	for|for
1480:13	control|(
1480:14	name|i
1480:16	operator|=
1480:18	literal|0
1480:19	init|;
1480:21	name|i
1480:23	operator|<
1480:25	name|AUDIT_INODE_BUCKETS
1480:44	condition|;
1480:46	name|i
1480:47	operator|++
1480:49	control|)
1481:17	name|INIT_LIST_HEAD
1481:31	argument_list|(
1481:32	operator|&
1481:33	name|audit_inode_hash
1481:49	index|[
1481:50	name|i
1481:51	index|]
1481:52	argument_list|)
1481:53	expr_stmt|;
1483:9	name|pr_info
1483:16	argument_list|(
1483:17	literal|"initializing netlink subsys (%s)\n"
1483:53	argument_list|,
1484:17	name|audit_default
1484:30	condition|?
1484:33	literal|"enabled"
1484:43	else|:
1484:45	literal|"disabled"
1484:55	argument_list|)
1484:56	expr_stmt|;
1485:9	name|register_pernet_subsys
1485:31	argument_list|(
1485:32	operator|&
1485:33	name|audit_net_ops
1485:46	argument_list|)
1485:47	expr_stmt|;
1487:9	name|audit_initialized
1487:27	operator|=
1487:29	name|AUDIT_INITIALIZED
1487:46	expr_stmt|;
1488:9	name|audit_enabled
1488:23	operator|=
1488:25	name|audit_default
1488:38	expr_stmt|;
1489:9	name|audit_ever_enabled
1489:28	operator||=
1489:31	operator|!
1489:32	operator|!
1489:33	name|audit_default
1489:46	expr_stmt|;
1491:9	name|kauditd_task
1491:22	operator|=
1491:24	name|kthread_run
1491:35	argument_list|(
1491:36	name|kauditd_thread
1491:50	argument_list|,
1491:52	name|NULL
1491:56	argument_list|,
1491:58	literal|"kauditd"
1491:67	argument_list|)
1491:68	expr_stmt|;
1492:9	if|if
1492:12	condition|(
1492:13	name|IS_ERR
1492:19	argument_list|(
1492:20	name|kauditd_task
1492:32	argument_list|)
1492:33	condition|)
1492:35	block|{
1493:17	name|int
1493:21	name|err
1493:25	init|=
1493:27	name|PTR_ERR
1493:34	argument_list|(
1493:35	name|kauditd_task
1493:47	argument_list|)
1493:48	decl_stmt|;
1494:17	name|panic
1494:22	argument_list|(
1494:23	literal|"audit: failed to start the kauditd thread (%d)\n"
1494:73	argument_list|,
1494:75	name|err
1494:78	argument_list|)
1494:79	expr_stmt|;
1494:80	block|}
1497:9	name|audit_log
1497:18	argument_list|(
1497:19	name|NULL
1497:23	argument_list|,
1497:25	name|GFP_KERNEL
1497:35	argument_list|,
1497:37	name|AUDIT_KERNEL
1497:49	argument_list|,
1498:17	literal|"state=initialized audit_enabled=%u res=1"
1498:59	argument_list|,
1499:18	name|audit_enabled
1499:31	argument_list|)
1499:32	expr_stmt|;
1501:9	return|return
1501:16	literal|0
1501:17	return|;
1501:18	block|}
-:-	end_function
-:-	begin_expr_stmt
1503:1	name|__initcall
1503:11	argument_list|(
1503:12	name|audit_init
1503:22	argument_list|)
1503:23	expr_stmt|;
-:-	end_expr_stmt
-:-	begin_comment
1505:1	comment|/* Process kernel command-line parameter at boot time.  audit=0 or audit=1. */
-:-	end_comment
-:-	begin_function
1506:1	specifier|static
1506:8	name|int
1506:12	name|__init
1506:19	name|audit_enable
1506:31	parameter_list|(
1506:32	name|char
1506:37	modifier|*
1506:38	name|str
1506:41	parameter_list|)
1507:1	block|{
1508:9	name|audit_default
1508:23	operator|=
1508:25	operator|!
1508:26	operator|!
1508:27	name|simple_strtol
1508:40	argument_list|(
1508:41	name|str
1508:44	argument_list|,
1508:46	name|NULL
1508:50	argument_list|,
1508:52	literal|0
1508:53	argument_list|)
1508:54	expr_stmt|;
1509:9	if|if
1509:12	condition|(
1509:13	operator|!
1509:14	name|audit_default
1509:27	condition|)
1510:17	name|audit_initialized
1510:35	operator|=
1510:37	name|AUDIT_DISABLED
1510:51	expr_stmt|;
1512:9	name|pr_info
1512:16	argument_list|(
1512:17	literal|"%s\n"
1512:23	argument_list|,
1512:25	name|audit_default
1512:38	condition|?
1513:17	literal|"enabled (after initialization)"
1513:50	else|:
1513:52	literal|"disabled (until reboot)"
1513:77	argument_list|)
1513:78	expr_stmt|;
1515:9	return|return
1515:16	literal|1
1515:17	return|;
1515:18	block|}
-:-	end_function
-:-	begin_expr_stmt
1517:1	name|__setup
1517:8	argument_list|(
1517:9	literal|"audit="
1517:17	argument_list|,
1517:19	name|audit_enable
1517:31	argument_list|)
1517:32	expr_stmt|;
-:-	end_expr_stmt
-:-	begin_comment
1519:1	comment|/* Process kernel command-line parameter at boot time.  * audit_backlog_limit=<n> */
-:-	end_comment
-:-	begin_function
1521:1	specifier|static
1521:8	name|int
1521:12	name|__init
1521:19	name|audit_backlog_limit_set
1521:42	parameter_list|(
1521:43	name|char
1521:48	modifier|*
1521:49	name|str
1521:52	parameter_list|)
1522:1	block|{
1523:9	name|u32
1523:13	name|audit_backlog_limit_arg
1523:36	decl_stmt|;
1525:9	name|pr_info
1525:16	argument_list|(
1525:17	literal|"audit_backlog_limit: "
1525:40	argument_list|)
1525:41	expr_stmt|;
1526:9	if|if
1526:12	condition|(
1526:13	name|kstrtouint
1526:23	argument_list|(
1526:24	name|str
1526:27	argument_list|,
1526:29	literal|0
1526:30	argument_list|,
1526:32	operator|&
1526:33	name|audit_backlog_limit_arg
1526:56	argument_list|)
1526:57	condition|)
1526:59	block|{
1527:17	name|pr_cont
1527:24	argument_list|(
1527:25	literal|"using default of %u, unable to parse %s\n"
1527:68	argument_list|,
1528:25	name|audit_backlog_limit
1528:44	argument_list|,
1528:46	name|str
1528:49	argument_list|)
1528:50	expr_stmt|;
1529:17	return|return
1529:24	literal|1
1529:25	return|;
1529:26	block|}
1532:9	name|audit_backlog_limit
1532:29	operator|=
1532:31	name|audit_backlog_limit_arg
1532:54	expr_stmt|;
1533:9	name|pr_cont
1533:16	argument_list|(
1533:17	literal|"%d\n"
1533:23	argument_list|,
1533:25	name|audit_backlog_limit
1533:44	argument_list|)
1533:45	expr_stmt|;
1535:9	return|return
1535:16	literal|1
1535:17	return|;
1535:18	block|}
-:-	end_function
-:-	begin_expr_stmt
1537:1	name|__setup
1537:8	argument_list|(
1537:9	literal|"audit_backlog_limit="
1537:31	argument_list|,
1537:33	name|audit_backlog_limit_set
1537:56	argument_list|)
1537:57	expr_stmt|;
-:-	end_expr_stmt
-:-	begin_function
1539:1	specifier|static
1539:8	name|void
1539:13	name|audit_buffer_free
1539:30	parameter_list|(
1539:31	name|struct
1539:38	name|audit_buffer
1539:51	modifier|*
1539:52	name|ab
1539:54	parameter_list|)
1540:1	block|{
1541:9	name|unsigned
1541:18	name|long
1541:23	name|flags
1541:28	decl_stmt|;
1543:9	if|if
1543:12	condition|(
1543:13	operator|!
1543:14	name|ab
1543:16	condition|)
1544:17	return|return;
1546:9	name|kfree_skb
1546:18	argument_list|(
1546:19	name|ab
1546:21	operator|->
1546:23	name|skb
1546:26	argument_list|)
1546:27	expr_stmt|;
1547:9	name|spin_lock_irqsave
1547:26	argument_list|(
1547:27	operator|&
1547:28	name|audit_freelist_lock
1547:47	argument_list|,
1547:49	name|flags
1547:54	argument_list|)
1547:55	expr_stmt|;
1548:9	if|if
1548:12	condition|(
1548:13	name|audit_freelist_count
1548:34	operator|>
1548:36	name|AUDIT_MAXFREE
1548:49	condition|)
1549:17	name|kfree
1549:22	argument_list|(
1549:23	name|ab
1549:25	argument_list|)
1549:26	expr_stmt|;
1550:9	else|else
1550:14	block|{
1551:17	name|audit_freelist_count
1551:37	operator|++
1551:39	expr_stmt|;
1552:17	name|list_add
1552:25	argument_list|(
1552:26	operator|&
1552:27	name|ab
1552:29	operator|->
1552:31	name|list
1552:35	argument_list|,
1552:37	operator|&
1552:38	name|audit_freelist
1552:52	argument_list|)
1552:53	expr_stmt|;
1552:54	block|}
1554:9	name|spin_unlock_irqrestore
1554:31	argument_list|(
1554:32	operator|&
1554:33	name|audit_freelist_lock
1554:52	argument_list|,
1554:54	name|flags
1554:59	argument_list|)
1554:60	expr_stmt|;
1554:61	block|}
-:-	end_function
-:-	begin_function
1557:1	specifier|static
1557:8	name|struct
1557:15	name|audit_buffer
1557:28	modifier|*
1557:30	name|audit_buffer_alloc
1557:48	parameter_list|(
1557:49	name|struct
1557:56	name|audit_context
1557:70	modifier|*
1557:71	name|ctx
1557:74	parameter_list|,
1558:49	name|gfp_t
1558:55	name|gfp_mask
1558:63	parameter_list|,
1558:65	name|int
1558:69	name|type
1558:73	parameter_list|)
1559:1	block|{
1560:9	name|unsigned
1560:18	name|long
1560:23	name|flags
1560:28	decl_stmt|;
1561:9	name|struct
1561:16	name|audit_buffer
1561:29	modifier|*
1561:30	name|ab
1561:33	init|=
1561:35	name|NULL
1561:39	decl_stmt|;
1562:9	name|struct
1562:16	name|nlmsghdr
1562:25	modifier|*
1562:26	name|nlh
1562:29	decl_stmt|;
1564:9	name|spin_lock_irqsave
1564:26	argument_list|(
1564:27	operator|&
1564:28	name|audit_freelist_lock
1564:47	argument_list|,
1564:49	name|flags
1564:54	argument_list|)
1564:55	expr_stmt|;
1565:9	if|if
1565:12	condition|(
1565:13	operator|!
1565:14	name|list_empty
1565:24	argument_list|(
1565:25	operator|&
1565:26	name|audit_freelist
1565:40	argument_list|)
1565:41	condition|)
1565:43	block|{
1566:17	name|ab
1566:20	operator|=
1566:22	name|list_entry
1566:32	argument_list|(
1566:33	name|audit_freelist
1566:47	operator|.
1566:48	name|next
1566:52	argument_list|,
1567:33	expr|struct
1567:40	name|audit_buffer
1567:52	argument_list|,
1567:54	name|list
1567:58	argument_list|)
1567:59	expr_stmt|;
1568:17	name|list_del
1568:25	argument_list|(
1568:26	operator|&
1568:27	name|ab
1568:29	operator|->
1568:31	name|list
1568:35	argument_list|)
1568:36	expr_stmt|;
1569:17	operator|--
1569:19	name|audit_freelist_count
1569:39	expr_stmt|;
1569:40	block|}
1571:9	name|spin_unlock_irqrestore
1571:31	argument_list|(
1571:32	operator|&
1571:33	name|audit_freelist_lock
1571:52	argument_list|,
1571:54	name|flags
1571:59	argument_list|)
1571:60	expr_stmt|;
1573:9	if|if
1573:12	condition|(
1573:13	operator|!
1573:14	name|ab
1573:16	condition|)
1573:18	block|{
1574:17	name|ab
1574:20	operator|=
1574:22	name|kmalloc
1574:29	argument_list|(
1574:30	sizeof|sizeof
1574:36	argument_list|(
1574:37	operator|*
1574:38	name|ab
1574:40	argument_list|)
1574:41	argument_list|,
1574:43	name|gfp_mask
1574:51	argument_list|)
1574:52	expr_stmt|;
1575:17	if|if
1575:20	condition|(
1575:21	operator|!
1575:22	name|ab
1575:24	condition|)
1576:25	goto|goto
1576:30	name|err
1576:33	goto|;
1576:34	block|}
1579:9	name|ab
1579:11	operator|->
1579:13	name|ctx
1579:17	operator|=
1579:19	name|ctx
1579:22	expr_stmt|;
1580:9	name|ab
1580:11	operator|->
1580:13	name|gfp_mask
1580:22	operator|=
1580:24	name|gfp_mask
1580:32	expr_stmt|;
1582:9	name|ab
1582:11	operator|->
1582:13	name|skb
1582:17	operator|=
1582:19	name|nlmsg_new
1582:28	argument_list|(
1582:29	name|AUDIT_BUFSIZ
1582:41	argument_list|,
1582:43	name|gfp_mask
1582:51	argument_list|)
1582:52	expr_stmt|;
1583:9	if|if
1583:12	condition|(
1583:13	operator|!
1583:14	name|ab
1583:16	operator|->
1583:18	name|skb
1583:21	condition|)
1584:17	goto|goto
1584:22	name|err
1584:25	goto|;
1586:9	name|nlh
1586:13	operator|=
1586:15	name|nlmsg_put
1586:24	argument_list|(
1586:25	name|ab
1586:27	operator|->
1586:29	name|skb
1586:32	argument_list|,
1586:34	literal|0
1586:35	argument_list|,
1586:37	literal|0
1586:38	argument_list|,
1586:40	name|type
1586:44	argument_list|,
1586:46	literal|0
1586:47	argument_list|,
1586:49	literal|0
1586:50	argument_list|)
1586:51	expr_stmt|;
1587:9	if|if
1587:12	condition|(
1587:13	operator|!
1587:14	name|nlh
1587:17	condition|)
1588:17	goto|goto
1588:22	name|out_kfree_skb
1588:35	goto|;
1590:9	return|return
1590:16	name|ab
1590:18	return|;
1592:1	name|out_kfree_skb
1592:14	label|:
1593:9	name|kfree_skb
1593:18	argument_list|(
1593:19	name|ab
1593:21	operator|->
1593:23	name|skb
1593:26	argument_list|)
1593:27	expr_stmt|;
1594:9	name|ab
1594:11	operator|->
1594:13	name|skb
1594:17	operator|=
1594:19	name|NULL
1594:23	expr_stmt|;
1595:1	name|err
1595:4	label|:
1596:9	name|audit_buffer_free
1596:26	argument_list|(
1596:27	name|ab
1596:29	argument_list|)
1596:30	expr_stmt|;
1597:9	return|return
1597:16	name|NULL
1597:20	return|;
1597:21	block|}
-:-	end_function
-:-	begin_comment
1600:1	comment|/**  * audit_serial - compute a serial number for the audit record  *  * Compute a serial number for the audit record.  Audit records are  * written to user-space as soon as they are generated, so a complete  * audit record may be written in several pieces.  The timestamp of the  * record and this serial number are used by the user-space tools to  * determine which pieces belong to the same audit record.  The  * (timestamp,serial) tuple is unique for each syscall and is live from  * syscall entry to syscall exit.  *  * NOTE: Another possibility is to store the formatted records off the  * audit context (for those records that have a context), and emit them  * all at syscall exit.  However, this could delay the reporting of  * significant errors until syscall exit (or never, if the system  * halts).  */
-:-	end_comment
-:-	begin_function
1617:1	name|unsigned
1617:10	name|int
1617:14	name|audit_serial
1617:26	parameter_list|(
1617:27	name|void
1617:31	parameter_list|)
1618:1	block|{
1619:9	specifier|static
1619:16	name|atomic_t
1619:25	name|serial
1619:32	init|=
1619:34	name|ATOMIC_INIT
1619:45	argument_list|(
1619:46	literal|0
1619:47	argument_list|)
1619:48	decl_stmt|;
1621:9	return|return
1621:16	name|atomic_add_return
1621:33	argument_list|(
1621:34	literal|1
1621:35	argument_list|,
1621:37	operator|&
1621:38	name|serial
1621:44	argument_list|)
1621:45	return|;
1621:46	block|}
-:-	end_function
-:-	begin_function
1624:1	specifier|static
1624:8	specifier|inline
1624:15	name|void
1624:20	name|audit_get_stamp
1624:35	parameter_list|(
1624:36	name|struct
1624:43	name|audit_context
1624:57	modifier|*
1624:58	name|ctx
1624:61	parameter_list|,
1625:36	name|struct
1625:43	name|timespec
1625:52	modifier|*
1625:53	name|t
1625:54	parameter_list|,
1625:56	name|unsigned
1625:65	name|int
1625:69	modifier|*
1625:70	name|serial
1625:76	parameter_list|)
1626:1	block|{
1627:9	if|if
1627:12	condition|(
1627:13	operator|!
1627:14	name|ctx
1627:18	operator|||
1627:21	operator|!
1627:22	name|auditsc_get_stamp
1627:39	argument_list|(
1627:40	name|ctx
1627:43	argument_list|,
1627:45	name|t
1627:46	argument_list|,
1627:48	name|serial
1627:54	argument_list|)
1627:55	condition|)
1627:57	block|{
1628:17	operator|*
1628:18	name|t
1628:20	operator|=
1628:22	name|CURRENT_TIME
1628:34	expr_stmt|;
1629:17	operator|*
1629:18	name|serial
1629:25	operator|=
1629:27	name|audit_serial
1629:39	argument_list|()
1629:41	expr_stmt|;
1629:42	block|}
1630:10	block|}
-:-	end_function
-:-	begin_comment
1633:1	comment|/**  * audit_log_start - obtain an audit buffer  * @ctx: audit_context (may be NULL)  * @gfp_mask: type of allocation  * @type: audit message type  *  * Returns audit_buffer pointer on success or NULL on error.  *  * Obtain an audit buffer.  This routine does locking to obtain the  * audit buffer, but then no locking is required for calls to  * audit_log_*format.  If the task (ctx) is a task that is currently in a  * syscall, then the syscall is marked as auditable and an audit record  * will be written at syscall exit.  If there is no associated task, then  * task context (ctx) should be NULL.  */
-:-	end_comment
-:-	begin_function
1648:1	name|struct
1648:8	name|audit_buffer
1648:21	modifier|*
1648:22	name|audit_log_start
1648:37	parameter_list|(
1648:38	name|struct
1648:45	name|audit_context
1648:59	modifier|*
1648:60	name|ctx
1648:63	parameter_list|,
1648:65	name|gfp_t
1648:71	name|gfp_mask
1648:79	parameter_list|,
1649:38	name|int
1649:42	name|type
1649:46	parameter_list|)
1650:1	block|{
1651:9	name|struct
1651:16	name|audit_buffer
1651:29	modifier|*
1651:30	name|ab
1651:32	decl_stmt|;
1652:9	name|struct
1652:16	name|timespec
1652:25	name|t
1652:26	decl_stmt|;
1653:9	name|unsigned
1653:18	name|int
1653:22	name|uninitialized_var
1653:39	argument_list|(
1653:40	name|serial
1653:46	argument_list|)
1653:47	decl_stmt|;
1655:9	if|if
1655:12	condition|(
1655:13	name|audit_initialized
1655:31	operator|!=
1655:34	name|AUDIT_INITIALIZED
1655:51	condition|)
1656:17	return|return
1656:24	name|NULL
1656:28	return|;
1658:9	if|if
1658:12	condition|(
1658:13	name|unlikely
1658:21	argument_list|(
1658:22	operator|!
1658:23	name|audit_filter
1658:35	argument_list|(
1658:36	name|type
1658:40	argument_list|,
1658:42	name|AUDIT_FILTER_TYPE
1658:59	argument_list|)
1658:60	argument_list|)
1658:61	condition|)
1659:17	return|return
1659:24	name|NULL
1659:28	return|;
1661:9	comment|/* NOTE: don't ever fail/sleep on these two conditions: 	 * 1. auditd generated record - since we need auditd to drain the 	 *    queue; also, when we are checking for auditd, compare PIDs using 	 *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg() 	 *    using a PID anchored in the caller's namespace 	 * 2. generator holding the audit_cmd_mutex - we don't want to block 	 *    while holding the mutex */
1668:9	if|if
1668:12	condition|(
1668:13	operator|!
1668:14	operator|(
1668:15	name|auditd_test_task
1668:31	argument_list|(
1668:32	name|current
1668:39	argument_list|)
1668:41	operator|||
1669:15	operator|(
1669:16	name|current
1669:24	operator|==
1669:27	name|__mutex_owner
1669:40	argument_list|(
1669:41	operator|&
1669:42	name|audit_cmd_mutex
1669:57	argument_list|)
1669:58	operator|)
1669:59	operator|)
1669:60	condition|)
1669:62	block|{
1670:17	name|long
1670:22	name|stime
1670:28	init|=
1670:30	name|audit_backlog_wait_time
1670:53	decl_stmt|;
1672:17	while|while
1672:23	condition|(
1672:24	name|audit_backlog_limit
1672:44	operator|&&
1673:24	operator|(
1673:25	name|skb_queue_len
1673:38	argument_list|(
1673:39	operator|&
1673:40	name|audit_queue
1673:51	argument_list|)
1673:53	operator|>
1673:55	name|audit_backlog_limit
1673:74	operator|)
1673:75	condition|)
1673:77	block|{
1674:25	comment|/* wake kauditd to try and flush the queue */
1675:25	name|wake_up_interruptible
1675:46	argument_list|(
1675:47	operator|&
1675:48	name|kauditd_wait
1675:60	argument_list|)
1675:61	expr_stmt|;
1677:25	comment|/* sleep if we are allowed and we haven't exhausted our 			 * backlog wait limit */
1679:25	if|if
1679:28	condition|(
1679:29	name|gfpflags_allow_blocking
1679:52	argument_list|(
1679:53	name|gfp_mask
1679:61	argument_list|)
1679:63	operator|&&
1679:66	operator|(
1679:67	name|stime
1679:73	operator|>
1679:75	literal|0
1679:76	operator|)
1679:77	condition|)
1679:79	block|{
1680:33	name|DECLARE_WAITQUEUE
1680:50	argument_list|(
1680:51	name|wait
1680:55	argument_list|,
1680:57	name|current
1680:64	argument_list|)
1680:65	expr_stmt|;
1682:33	name|add_wait_queue_exclusive
1682:57	argument_list|(
1682:58	operator|&
1682:59	name|audit_backlog_wait
1682:77	argument_list|,
1683:58	operator|&
1683:59	name|wait
1683:63	argument_list|)
1683:64	expr_stmt|;
1684:33	name|set_current_state
1684:50	argument_list|(
1684:51	name|TASK_UNINTERRUPTIBLE
1684:71	argument_list|)
1684:72	expr_stmt|;
1685:33	name|stime
1685:39	operator|=
1685:41	name|schedule_timeout
1685:57	argument_list|(
1685:58	name|stime
1685:63	argument_list|)
1685:64	expr_stmt|;
1686:33	name|remove_wait_queue
1686:50	argument_list|(
1686:51	operator|&
1686:52	name|audit_backlog_wait
1686:70	argument_list|,
1686:72	operator|&
1686:73	name|wait
1686:77	argument_list|)
1686:78	expr_stmt|;
1686:79	block|}
1687:27	else|else
1687:32	block|{
1688:33	if|if
1688:36	condition|(
1688:37	name|audit_rate_check
1688:53	argument_list|()
1688:56	operator|&&
1688:59	name|printk_ratelimit
1688:75	argument_list|()
1688:77	condition|)
1689:41	name|pr_warn
1689:48	argument_list|(
1689:49	literal|"audit_backlog=%d> audit_backlog_limit=%d\n"
1689:97	argument_list|,
1690:49	name|skb_queue_len
1690:62	argument_list|(
1690:63	operator|&
1690:64	name|audit_queue
1690:75	argument_list|)
1690:76	argument_list|,
1691:49	name|audit_backlog_limit
1691:68	argument_list|)
1691:69	expr_stmt|;
1692:33	name|audit_log_lost
1692:47	argument_list|(
1692:48	literal|"backlog limit exceeded"
1692:72	argument_list|)
1692:73	expr_stmt|;
1693:33	return|return
1693:40	name|NULL
1693:44	return|;
1693:45	block|}
1694:26	block|}
1695:18	block|}
1698:9	name|ab
1698:12	operator|=
1698:14	name|audit_buffer_alloc
1698:32	argument_list|(
1698:33	name|ctx
1698:36	argument_list|,
1698:38	name|gfp_mask
1698:46	argument_list|,
1698:48	name|type
1698:52	argument_list|)
1698:53	expr_stmt|;
1699:9	if|if
1699:12	condition|(
1699:13	operator|!
1699:14	name|ab
1699:16	condition|)
1699:18	block|{
1700:17	name|audit_log_lost
1700:31	argument_list|(
1700:32	literal|"out of memory in audit_log_start"
1700:66	argument_list|)
1700:67	expr_stmt|;
1701:17	return|return
1701:24	name|NULL
1701:28	return|;
1701:29	block|}
1704:9	name|audit_get_stamp
1704:24	argument_list|(
1704:25	name|ab
1704:27	operator|->
1704:29	name|ctx
1704:32	argument_list|,
1704:34	operator|&
1704:35	name|t
1704:36	argument_list|,
1704:38	operator|&
1704:39	name|serial
1704:45	argument_list|)
1704:46	expr_stmt|;
1705:9	name|audit_log_format
1705:25	argument_list|(
1705:26	name|ab
1705:28	argument_list|,
1705:30	literal|"audit(%lu.%03lu:%u): "
1705:53	argument_list|,
1706:26	name|t
1706:27	operator|.
1706:28	name|tv_sec
1706:34	argument_list|,
1706:36	name|t
1706:37	operator|.
1706:38	name|tv_nsec
1706:45	operator|/
1706:46	literal|1000000
1706:53	argument_list|,
1706:55	name|serial
1706:61	argument_list|)
1706:62	expr_stmt|;
1708:9	return|return
1708:16	name|ab
1708:18	return|;
1708:19	block|}
-:-	end_function
-:-	begin_comment
1711:1	comment|/**  * audit_expand - expand skb in the audit buffer  * @ab: audit_buffer  * @extra: space to add at tail of the skb  *  * Returns 0 (no space) on failed expansion, or available space if  * successful.  */
-:-	end_comment
-:-	begin_function
1719:1	specifier|static
1719:8	specifier|inline
1719:15	name|int
1719:19	name|audit_expand
1719:31	parameter_list|(
1719:32	name|struct
1719:39	name|audit_buffer
1719:52	modifier|*
1719:53	name|ab
1719:55	parameter_list|,
1719:57	name|int
1719:61	name|extra
1719:66	parameter_list|)
1720:1	block|{
1721:9	name|struct
1721:16	name|sk_buff
1721:24	modifier|*
1721:25	name|skb
1721:29	init|=
1721:31	name|ab
1721:33	operator|->
1721:35	name|skb
1721:38	decl_stmt|;
1722:9	name|int
1722:13	name|oldtail
1722:21	init|=
1722:23	name|skb_tailroom
1722:35	argument_list|(
1722:36	name|skb
1722:39	argument_list|)
1722:40	decl_stmt|;
1723:9	name|int
1723:13	name|ret
1723:17	init|=
1723:19	name|pskb_expand_head
1723:35	argument_list|(
1723:36	name|skb
1723:39	argument_list|,
1723:41	literal|0
1723:42	argument_list|,
1723:44	name|extra
1723:49	argument_list|,
1723:51	name|ab
1723:53	operator|->
1723:55	name|gfp_mask
1723:63	argument_list|)
1723:64	decl_stmt|;
1724:9	name|int
1724:13	name|newtail
1724:21	init|=
1724:23	name|skb_tailroom
1724:35	argument_list|(
1724:36	name|skb
1724:39	argument_list|)
1724:40	decl_stmt|;
1726:9	if|if
1726:12	condition|(
1726:13	name|ret
1726:17	operator|<
1726:19	literal|0
1726:20	condition|)
1726:22	block|{
1727:17	name|audit_log_lost
1727:31	argument_list|(
1727:32	literal|"out of memory in audit_expand"
1727:63	argument_list|)
1727:64	expr_stmt|;
1728:17	return|return
1728:24	literal|0
1728:25	return|;
1728:26	block|}
1731:9	name|skb
1731:12	operator|->
1731:14	name|truesize
1731:23	operator|+=
1731:26	name|newtail
1731:34	operator|-
1731:36	name|oldtail
1731:43	expr_stmt|;
1732:9	return|return
1732:16	name|newtail
1732:23	return|;
1732:24	block|}
-:-	end_function
-:-	begin_comment
1735:1	comment|/*  * Format an audit message into the audit buffer.  If there isn't enough  * room in the audit buffer, more room will be allocated and vsnprint  * will be called a second time.  Currently, we assume that a printk  * can't format message larger than 1024 bytes, so we don't either.  */
-:-	end_comment
-:-	begin_function
1741:1	specifier|static
1741:8	name|void
1741:13	name|audit_log_vformat
1741:30	parameter_list|(
1741:31	name|struct
1741:38	name|audit_buffer
1741:51	modifier|*
1741:52	name|ab
1741:54	parameter_list|,
1741:56	specifier|const
1741:62	name|char
1741:67	modifier|*
1741:68	name|fmt
1741:71	parameter_list|,
1742:31	name|va_list
1742:39	name|args
1742:43	parameter_list|)
1743:1	block|{
1744:9	name|int
1744:13	name|len
1744:16	decl_stmt|,
1744:18	name|avail
1744:23	decl_stmt|;
1745:9	name|struct
1745:16	name|sk_buff
1745:24	modifier|*
1745:25	name|skb
1745:28	decl_stmt|;
1746:9	name|va_list
1746:17	name|args2
1746:22	decl_stmt|;
1748:9	if|if
1748:12	condition|(
1748:13	operator|!
1748:14	name|ab
1748:16	condition|)
1749:17	return|return;
1751:9	name|BUG_ON
1751:15	argument_list|(
1751:16	operator|!
1751:17	name|ab
1751:19	operator|->
1751:21	name|skb
1751:24	argument_list|)
1751:25	expr_stmt|;
1752:9	name|skb
1752:13	operator|=
1752:15	name|ab
1752:17	operator|->
1752:19	name|skb
1752:22	expr_stmt|;
1753:9	name|avail
1753:15	operator|=
1753:17	name|skb_tailroom
1753:29	argument_list|(
1753:30	name|skb
1753:33	argument_list|)
1753:34	expr_stmt|;
1754:9	if|if
1754:12	condition|(
1754:13	name|avail
1754:19	operator|==
1754:22	literal|0
1754:23	condition|)
1754:25	block|{
1755:17	name|avail
1755:23	operator|=
1755:25	name|audit_expand
1755:37	argument_list|(
1755:38	name|ab
1755:40	argument_list|,
1755:42	name|AUDIT_BUFSIZ
1755:54	argument_list|)
1755:55	expr_stmt|;
1756:17	if|if
1756:20	condition|(
1756:21	operator|!
1756:22	name|avail
1756:27	condition|)
1757:25	goto|goto
1757:30	name|out
1757:33	goto|;
1757:34	block|}
1759:9	name|va_copy
1759:16	argument_list|(
1759:17	name|args2
1759:22	argument_list|,
1759:24	name|args
1759:28	argument_list|)
1759:29	expr_stmt|;
1760:9	name|len
1760:13	operator|=
1760:15	name|vsnprintf
1760:24	argument_list|(
1760:25	name|skb_tail_pointer
1760:41	argument_list|(
1760:42	name|skb
1760:45	argument_list|)
1760:46	argument_list|,
1760:48	name|avail
1760:53	argument_list|,
1760:55	name|fmt
1760:58	argument_list|,
1760:60	name|args
1760:64	argument_list|)
1760:65	expr_stmt|;
1761:9	if|if
1761:12	condition|(
1761:13	name|len
1761:17	operator|>=
1761:20	name|avail
1761:25	condition|)
1761:27	block|{
1762:17	comment|/* The printk buffer is 1024 bytes long, so if we get 		 * here and AUDIT_BUFSIZ is at least 1024, then we can 		 * log everything that printk could have logged. */
1765:17	name|avail
1765:23	operator|=
1765:25	name|audit_expand
1765:37	argument_list|(
1765:38	name|ab
1765:40	argument_list|,
1766:25	name|max_t
1766:30	argument_list|(
1766:31	name|unsigned
1766:39	argument_list|,
1766:41	name|AUDIT_BUFSIZ
1766:53	argument_list|,
1766:55	literal|1
1766:56	operator|+
1766:57	name|len
1766:60	operator|-
1766:61	name|avail
1766:66	argument_list|)
1766:67	argument_list|)
1766:68	expr_stmt|;
1767:17	if|if
1767:20	condition|(
1767:21	operator|!
1767:22	name|avail
1767:27	condition|)
1768:25	goto|goto
1768:30	name|out_va_end
1768:40	goto|;
1769:17	name|len
1769:21	operator|=
1769:23	name|vsnprintf
1769:32	argument_list|(
1769:33	name|skb_tail_pointer
1769:49	argument_list|(
1769:50	name|skb
1769:53	argument_list|)
1769:54	argument_list|,
1769:56	name|avail
1769:61	argument_list|,
1769:63	name|fmt
1769:66	argument_list|,
1769:68	name|args2
1769:73	argument_list|)
1769:74	expr_stmt|;
1769:75	block|}
1771:9	if|if
1771:12	condition|(
1771:13	name|len
1771:17	operator|>
1771:19	literal|0
1771:20	condition|)
1772:17	name|skb_put
1772:24	argument_list|(
1772:25	name|skb
1772:28	argument_list|,
1772:30	name|len
1772:33	argument_list|)
1772:34	expr_stmt|;
1773:1	name|out_va_end
1773:11	label|:
1774:9	name|va_end
1774:15	argument_list|(
1774:16	name|args2
1774:21	argument_list|)
1774:22	expr_stmt|;
1775:1	name|out
1775:4	label|:
1776:9	return|return;
1776:16	block|}
-:-	end_function
-:-	begin_comment
1779:1	comment|/**  * audit_log_format - format a message into the audit buffer.  * @ab: audit_buffer  * @fmt: format string  * @...: optional parameters matching @fmt string  *  * All the work is done in audit_log_vformat.  */
-:-	end_comment
-:-	begin_function
1787:1	name|void
1787:6	name|audit_log_format
1787:22	parameter_list|(
1787:23	name|struct
1787:30	name|audit_buffer
1787:43	modifier|*
1787:44	name|ab
1787:46	parameter_list|,
1787:48	specifier|const
1787:54	name|char
1787:59	modifier|*
1787:60	name|fmt
1787:63	parameter_list|,
1787:65	modifier|...
1787:68	parameter_list|)
1788:1	block|{
1789:9	name|va_list
1789:17	name|args
1789:21	decl_stmt|;
1791:9	if|if
1791:12	condition|(
1791:13	operator|!
1791:14	name|ab
1791:16	condition|)
1792:17	return|return;
1793:9	name|va_start
1793:17	argument_list|(
1793:18	name|args
1793:22	argument_list|,
1793:24	name|fmt
1793:27	argument_list|)
1793:28	expr_stmt|;
1794:9	name|audit_log_vformat
1794:26	argument_list|(
1794:27	name|ab
1794:29	argument_list|,
1794:31	name|fmt
1794:34	argument_list|,
1794:36	name|args
1794:40	argument_list|)
1794:41	expr_stmt|;
1795:9	name|va_end
1795:15	argument_list|(
1795:16	name|args
1795:20	argument_list|)
1795:21	expr_stmt|;
1795:22	block|}
-:-	end_function
-:-	begin_comment
1798:1	comment|/**  * audit_log_hex - convert a buffer to hex and append it to the audit skb  * @ab: the audit_buffer  * @buf: buffer to convert to hex  * @len: length of @buf to be converted  *  * No return value; failure to expand is silently ignored.  *  * This function will take the passed buf and convert it into a string of  * ascii hex digits. The new string is placed onto the skb.  */
-:-	end_comment
-:-	begin_function
1809:1	name|void
1809:6	name|audit_log_n_hex
1809:21	parameter_list|(
1809:22	name|struct
1809:29	name|audit_buffer
1809:42	modifier|*
1809:43	name|ab
1809:45	parameter_list|,
1809:47	specifier|const
1809:53	name|unsigned
1809:62	name|char
1809:67	modifier|*
1809:68	name|buf
1809:71	parameter_list|,
1810:17	name|size_t
1810:24	name|len
1810:27	parameter_list|)
1811:1	block|{
1812:9	name|int
1812:13	name|i
1812:14	decl_stmt|,
1812:16	name|avail
1812:21	decl_stmt|,
1812:23	name|new_len
1812:30	decl_stmt|;
1813:9	name|unsigned
1813:18	name|char
1813:23	modifier|*
1813:24	name|ptr
1813:27	decl_stmt|;
1814:9	name|struct
1814:16	name|sk_buff
1814:24	modifier|*
1814:25	name|skb
1814:28	decl_stmt|;
1816:9	if|if
1816:12	condition|(
1816:13	operator|!
1816:14	name|ab
1816:16	condition|)
1817:17	return|return;
1819:9	name|BUG_ON
1819:15	argument_list|(
1819:16	operator|!
1819:17	name|ab
1819:19	operator|->
1819:21	name|skb
1819:24	argument_list|)
1819:25	expr_stmt|;
1820:9	name|skb
1820:13	operator|=
1820:15	name|ab
1820:17	operator|->
1820:19	name|skb
1820:22	expr_stmt|;
1821:9	name|avail
1821:15	operator|=
1821:17	name|skb_tailroom
1821:29	argument_list|(
1821:30	name|skb
1821:33	argument_list|)
1821:34	expr_stmt|;
1822:9	name|new_len
1822:17	operator|=
1822:19	name|len
1822:22	operator|<<
1822:24	literal|1
1822:25	expr_stmt|;
1823:9	if|if
1823:12	condition|(
1823:13	name|new_len
1823:21	operator|>=
1823:24	name|avail
1823:29	condition|)
1823:31	block|{
1824:17	comment|/* Round the buffer request up to the next multiple */
1825:17	name|new_len
1825:25	operator|=
1825:27	name|AUDIT_BUFSIZ
1825:39	operator|*
1825:40	operator|(
1825:41	operator|(
1825:42	operator|(
1825:43	name|new_len
1825:50	operator|-
1825:51	name|avail
1825:56	operator|)
1825:57	operator|/
1825:58	name|AUDIT_BUFSIZ
1825:70	operator|)
1825:72	operator|+
1825:74	literal|1
1825:75	operator|)
1825:76	expr_stmt|;
1826:17	name|avail
1826:23	operator|=
1826:25	name|audit_expand
1826:37	argument_list|(
1826:38	name|ab
1826:40	argument_list|,
1826:42	name|new_len
1826:49	argument_list|)
1826:50	expr_stmt|;
1827:17	if|if
1827:20	condition|(
1827:21	operator|!
1827:22	name|avail
1827:27	condition|)
1828:25	return|return;
1828:32	block|}
1831:9	name|ptr
1831:13	operator|=
1831:15	name|skb_tail_pointer
1831:31	argument_list|(
1831:32	name|skb
1831:35	argument_list|)
1831:36	expr_stmt|;
1832:9	for|for
1832:13	control|(
1832:14	name|i
1832:16	operator|=
1832:18	literal|0
1832:19	init|;
1832:21	name|i
1832:23	operator|<
1832:25	name|len
1832:28	condition|;
1832:30	name|i
1832:31	operator|++
1832:33	control|)
1833:17	name|ptr
1833:21	operator|=
1833:23	name|hex_byte_pack_upper
1833:42	argument_list|(
1833:43	name|ptr
1833:46	argument_list|,
1833:48	name|buf
1833:51	index|[
1833:52	name|i
1833:53	index|]
1833:54	argument_list|)
1833:55	expr_stmt|;
1834:9	operator|*
1834:10	name|ptr
1834:14	operator|=
1834:16	literal|0
1834:17	expr_stmt|;
1835:9	name|skb_put
1835:16	argument_list|(
1835:17	name|skb
1835:20	argument_list|,
1835:22	name|len
1835:26	operator|<<
1835:29	literal|1
1835:30	argument_list|)
1835:31	expr_stmt|;
1835:33	comment|/* new string is twice the old string */
1835:33	block|}
-:-	end_function
-:-	begin_comment
1838:1	comment|/*  * Format a string of no more than slen characters into the audit buffer,  * enclosed in quote marks.  */
-:-	end_comment
-:-	begin_function
1842:1	name|void
1842:6	name|audit_log_n_string
1842:24	parameter_list|(
1842:25	name|struct
1842:32	name|audit_buffer
1842:45	modifier|*
1842:46	name|ab
1842:48	parameter_list|,
1842:50	specifier|const
1842:56	name|char
1842:61	modifier|*
1842:62	name|string
1842:68	parameter_list|,
1843:25	name|size_t
1843:32	name|slen
1843:36	parameter_list|)
1844:1	block|{
1845:9	name|int
1845:13	name|avail
1845:18	decl_stmt|,
1845:20	name|new_len
1845:27	decl_stmt|;
1846:9	name|unsigned
1846:18	name|char
1846:23	modifier|*
1846:24	name|ptr
1846:27	decl_stmt|;
1847:9	name|struct
1847:16	name|sk_buff
1847:24	modifier|*
1847:25	name|skb
1847:28	decl_stmt|;
1849:9	if|if
1849:12	condition|(
1849:13	operator|!
1849:14	name|ab
1849:16	condition|)
1850:17	return|return;
1852:9	name|BUG_ON
1852:15	argument_list|(
1852:16	operator|!
1852:17	name|ab
1852:19	operator|->
1852:21	name|skb
1852:24	argument_list|)
1852:25	expr_stmt|;
1853:9	name|skb
1853:13	operator|=
1853:15	name|ab
1853:17	operator|->
1853:19	name|skb
1853:22	expr_stmt|;
1854:9	name|avail
1854:15	operator|=
1854:17	name|skb_tailroom
1854:29	argument_list|(
1854:30	name|skb
1854:33	argument_list|)
1854:34	expr_stmt|;
1855:9	name|new_len
1855:17	operator|=
1855:19	name|slen
1855:24	operator|+
1855:26	literal|3
1855:27	expr_stmt|;
1855:33	comment|/* enclosing quotes + null terminator */
1856:9	if|if
1856:12	condition|(
1856:13	name|new_len
1856:21	operator|>
1856:23	name|avail
1856:28	condition|)
1856:30	block|{
1857:17	name|avail
1857:23	operator|=
1857:25	name|audit_expand
1857:37	argument_list|(
1857:38	name|ab
1857:40	argument_list|,
1857:42	name|new_len
1857:49	argument_list|)
1857:50	expr_stmt|;
1858:17	if|if
1858:20	condition|(
1858:21	operator|!
1858:22	name|avail
1858:27	condition|)
1859:25	return|return;
1859:32	block|}
1861:9	name|ptr
1861:13	operator|=
1861:15	name|skb_tail_pointer
1861:31	argument_list|(
1861:32	name|skb
1861:35	argument_list|)
1861:36	expr_stmt|;
1862:9	operator|*
1862:10	name|ptr
1862:13	operator|++
1862:16	operator|=
1862:18	literal|'"'
1862:21	expr_stmt|;
1863:9	name|memcpy
1863:15	argument_list|(
1863:16	name|ptr
1863:19	argument_list|,
1863:21	name|string
1863:27	argument_list|,
1863:29	name|slen
1863:33	argument_list|)
1863:34	expr_stmt|;
1864:9	name|ptr
1864:13	operator|+=
1864:16	name|slen
1864:20	expr_stmt|;
1865:9	operator|*
1865:10	name|ptr
1865:13	operator|++
1865:16	operator|=
1865:18	literal|'"'
1865:21	expr_stmt|;
1866:9	operator|*
1866:10	name|ptr
1866:14	operator|=
1866:16	literal|0
1866:17	expr_stmt|;
1867:9	name|skb_put
1867:16	argument_list|(
1867:17	name|skb
1867:20	argument_list|,
1867:22	name|slen
1867:27	operator|+
1867:29	literal|2
1867:30	argument_list|)
1867:31	expr_stmt|;
1867:33	comment|/* don't include null terminator */
1867:33	block|}
-:-	end_function
-:-	begin_comment
1870:1	comment|/**  * audit_string_contains_control - does a string need to be logged in hex  * @string: string to be checked  * @len: max length of the string to check  */
-:-	end_comment
-:-	begin_function
1875:1	name|bool
1875:6	name|audit_string_contains_control
1875:35	parameter_list|(
1875:36	specifier|const
1875:42	name|char
1875:47	modifier|*
1875:48	name|string
1875:54	parameter_list|,
1875:56	name|size_t
1875:63	name|len
1875:66	parameter_list|)
1876:1	block|{
1877:9	specifier|const
1877:15	name|unsigned
1877:24	name|char
1877:29	modifier|*
1877:30	name|p
1877:31	decl_stmt|;
1878:9	for|for
1878:13	control|(
1878:14	name|p
1878:16	operator|=
1878:18	name|string
1878:24	init|;
1878:26	name|p
1878:28	operator|<
1878:30	operator|(
1878:31	specifier|const
1878:37	name|unsigned
1878:46	name|char
1878:51	operator|*
1878:52	operator|)
1878:53	name|string
1878:60	operator|+
1878:62	name|len
1878:65	condition|;
1878:67	name|p
1878:68	operator|++
1878:70	control|)
1878:72	block|{
1879:17	if|if
1879:20	condition|(
1879:21	operator|*
1879:22	name|p
1879:24	operator|==
1879:27	literal|'"'
1879:31	operator|||
1879:34	operator|*
1879:35	name|p
1879:37	operator|<
1879:39	literal|0x21
1879:44	operator|||
1879:47	operator|*
1879:48	name|p
1879:50	operator|>
1879:52	literal|0x7e
1879:56	condition|)
1880:25	return|return
1880:32	name|true
1880:36	return|;
1880:37	block|}
1882:9	return|return
1882:16	name|false
1882:21	return|;
1882:22	block|}
-:-	end_function
-:-	begin_comment
1885:1	comment|/**  * audit_log_n_untrustedstring - log a string that may contain random characters  * @ab: audit_buffer  * @len: length of string (not including trailing null)  * @string: string to be logged  *  * This code will escape a string that is passed to it if the string  * contains a control character, unprintable character, double quote mark,  * or a space. Unescaped strings will start and end with a double quote mark.  * Strings that are escaped are printed in hex (2 digits per char).  *  * The caller specifies the number of characters in the string to log, which may  * or may not be the entire string.  */
-:-	end_comment
-:-	begin_function
1899:1	name|void
1899:6	name|audit_log_n_untrustedstring
1899:33	parameter_list|(
1899:34	name|struct
1899:41	name|audit_buffer
1899:54	modifier|*
1899:55	name|ab
1899:57	parameter_list|,
1899:59	specifier|const
1899:65	name|char
1899:70	modifier|*
1899:71	name|string
1899:77	parameter_list|,
1900:34	name|size_t
1900:41	name|len
1900:44	parameter_list|)
1901:1	block|{
1902:9	if|if
1902:12	condition|(
1902:13	name|audit_string_contains_control
1902:42	argument_list|(
1902:43	name|string
1902:49	argument_list|,
1902:51	name|len
1902:54	argument_list|)
1902:55	condition|)
1903:17	name|audit_log_n_hex
1903:32	argument_list|(
1903:33	name|ab
1903:35	argument_list|,
1903:37	name|string
1903:43	argument_list|,
1903:45	name|len
1903:48	argument_list|)
1903:49	expr_stmt|;
1904:9	else|else
1905:17	name|audit_log_n_string
1905:35	argument_list|(
1905:36	name|ab
1905:38	argument_list|,
1905:40	name|string
1905:46	argument_list|,
1905:48	name|len
1905:51	argument_list|)
1905:52	expr_stmt|;
1905:53	block|}
-:-	end_function
-:-	begin_comment
1908:1	comment|/**  * audit_log_untrustedstring - log a string that may contain random characters  * @ab: audit_buffer  * @string: string to be logged  *  * Same as audit_log_n_untrustedstring(), except that strlen is used to  * determine string length.  */
-:-	end_comment
-:-	begin_function
1916:1	name|void
1916:6	name|audit_log_untrustedstring
1916:31	parameter_list|(
1916:32	name|struct
1916:39	name|audit_buffer
1916:52	modifier|*
1916:53	name|ab
1916:55	parameter_list|,
1916:57	specifier|const
1916:63	name|char
1916:68	modifier|*
1916:69	name|string
1916:75	parameter_list|)
1917:1	block|{
1918:9	name|audit_log_n_untrustedstring
1918:36	argument_list|(
1918:37	name|ab
1918:39	argument_list|,
1918:41	name|string
1918:47	argument_list|,
1918:49	name|strlen
1918:55	argument_list|(
1918:56	name|string
1918:62	argument_list|)
1918:63	argument_list|)
1918:64	expr_stmt|;
1918:65	block|}
-:-	end_function
-:-	begin_comment
1921:1	comment|/* This is a helper-function to print the escaped d_path */
-:-	end_comment
-:-	begin_function
1922:1	name|void
1922:6	name|audit_log_d_path
1922:22	parameter_list|(
1922:23	name|struct
1922:30	name|audit_buffer
1922:43	modifier|*
1922:44	name|ab
1922:46	parameter_list|,
1922:48	specifier|const
1922:54	name|char
1922:59	modifier|*
1922:60	name|prefix
1922:66	parameter_list|,
1923:23	specifier|const
1923:29	name|struct
1923:36	name|path
1923:41	modifier|*
1923:42	name|path
1923:46	parameter_list|)
1924:1	block|{
1925:9	name|char
1925:14	modifier|*
1925:15	name|p
1925:16	decl_stmt|,
1925:18	modifier|*
1925:19	name|pathname
1925:27	decl_stmt|;
1927:9	if|if
1927:12	condition|(
1927:13	name|prefix
1927:19	condition|)
1928:17	name|audit_log_format
1928:33	argument_list|(
1928:34	name|ab
1928:36	argument_list|,
1928:38	literal|"%s"
1928:42	argument_list|,
1928:44	name|prefix
1928:50	argument_list|)
1928:51	expr_stmt|;
1930:9	comment|/* We will allow 11 spaces for ' (deleted)' to be appended */
1931:9	name|pathname
1931:18	operator|=
1931:20	name|kmalloc
1931:27	argument_list|(
1931:28	name|PATH_MAX
1931:36	operator|+
1931:37	literal|11
1931:39	argument_list|,
1931:41	name|ab
1931:43	operator|->
1931:45	name|gfp_mask
1931:53	argument_list|)
1931:54	expr_stmt|;
1932:9	if|if
1932:12	condition|(
1932:13	operator|!
1932:14	name|pathname
1932:22	condition|)
1932:24	block|{
1933:17	name|audit_log_string
1933:33	argument_list|(
1933:34	name|ab
1933:36	argument_list|,
1933:38	literal|"<no_memory>"
1933:57	argument_list|)
1933:52	expr_stmt|;
1934:17	return|return;
1934:24	block|}
1936:9	name|p
1936:11	operator|=
1936:13	name|d_path
1936:19	argument_list|(
1936:20	name|path
1936:24	argument_list|,
1936:26	name|pathname
1936:34	argument_list|,
1936:36	name|PATH_MAX
1936:44	operator|+
1936:45	literal|11
1936:47	argument_list|)
1936:48	expr_stmt|;
1937:9	if|if
1937:12	condition|(
1937:13	name|IS_ERR
1937:19	argument_list|(
1937:20	name|p
1937:21	argument_list|)
1937:22	condition|)
1937:24	block|{
1937:26	comment|/* Should never happen since we send PATH_MAX */
1938:17	comment|/* FIXME: can we save some information here? */
1939:17	name|audit_log_string
1939:33	argument_list|(
1939:34	name|ab
1939:36	argument_list|,
1939:38	literal|"<too_long>"
1939:56	argument_list|)
1939:51	expr_stmt|;
1939:52	block|}
1940:11	else|else
1941:17	name|audit_log_untrustedstring
1941:42	argument_list|(
1941:43	name|ab
1941:45	argument_list|,
1941:47	name|p
1941:48	argument_list|)
1941:49	expr_stmt|;
1942:9	name|kfree
1942:14	argument_list|(
1942:15	name|pathname
1942:23	argument_list|)
1942:24	expr_stmt|;
1942:25	block|}
-:-	end_function
-:-	begin_function
1945:1	name|void
1945:6	name|audit_log_session_info
1945:28	parameter_list|(
1945:29	name|struct
1945:36	name|audit_buffer
1945:49	modifier|*
1945:50	name|ab
1945:52	parameter_list|)
1946:1	block|{
1947:9	name|unsigned
1947:18	name|int
1947:22	name|sessionid
1947:32	init|=
1947:34	name|audit_get_sessionid
1947:53	argument_list|(
1947:54	name|current
1947:61	argument_list|)
1947:62	decl_stmt|;
1948:9	name|uid_t
1948:15	name|auid
1948:20	init|=
1948:22	name|from_kuid
1948:31	argument_list|(
1948:32	operator|&
1948:33	name|init_user_ns
1948:45	argument_list|,
1948:47	name|audit_get_loginuid
1948:65	argument_list|(
1948:66	name|current
1948:73	argument_list|)
1948:74	argument_list|)
1948:75	decl_stmt|;
1950:9	name|audit_log_format
1950:25	argument_list|(
1950:26	name|ab
1950:28	argument_list|,
1950:30	literal|" auid=%u ses=%u"
1950:47	argument_list|,
1950:49	name|auid
1950:53	argument_list|,
1950:55	name|sessionid
1950:64	argument_list|)
1950:65	expr_stmt|;
1950:66	block|}
-:-	end_function
-:-	begin_function
1953:1	name|void
1953:6	name|audit_log_key
1953:19	parameter_list|(
1953:20	name|struct
1953:27	name|audit_buffer
1953:40	modifier|*
1953:41	name|ab
1953:43	parameter_list|,
1953:45	name|char
1953:50	modifier|*
1953:51	name|key
1953:54	parameter_list|)
1954:1	block|{
1955:9	name|audit_log_format
1955:25	argument_list|(
1955:26	name|ab
1955:28	argument_list|,
1955:30	literal|" key="
1955:37	argument_list|)
1955:38	expr_stmt|;
1956:9	if|if
1956:12	condition|(
1956:13	name|key
1956:16	condition|)
1957:17	name|audit_log_untrustedstring
1957:42	argument_list|(
1957:43	name|ab
1957:45	argument_list|,
1957:47	name|key
1957:50	argument_list|)
1957:51	expr_stmt|;
1958:9	else|else
1959:17	name|audit_log_format
1959:33	argument_list|(
1959:34	name|ab
1959:36	argument_list|,
1959:38	literal|"(null)"
1959:46	argument_list|)
1959:47	expr_stmt|;
1959:48	block|}
-:-	end_function
-:-	begin_function
1962:1	name|void
1962:6	name|audit_log_cap
1962:19	parameter_list|(
1962:20	name|struct
1962:27	name|audit_buffer
1962:40	modifier|*
1962:41	name|ab
1962:43	parameter_list|,
1962:45	name|char
1962:50	modifier|*
1962:51	name|prefix
1962:57	parameter_list|,
1962:59	name|kernel_cap_t
1962:72	modifier|*
1962:73	name|cap
1962:76	parameter_list|)
1963:1	block|{
1964:9	name|int
1964:13	name|i
1964:14	decl_stmt|;
1966:9	name|audit_log_format
1966:25	argument_list|(
1966:26	name|ab
1966:28	argument_list|,
1966:30	literal|" %s="
1966:36	argument_list|,
1966:38	name|prefix
1966:44	argument_list|)
1966:45	expr_stmt|;
1967:9	name|CAP_FOR_EACH_U32
1967:25	argument_list|(
1967:26	argument|i
1967:27	argument_list|)
1967:29	block|{
1968:17	name|audit_log_format
1968:33	argument_list|(
1968:34	name|ab
1968:36	argument_list|,
1968:38	literal|"%08x"
1968:44	argument_list|,
1969:34	name|cap
1969:37	operator|->
1969:39	name|cap
1969:42	index|[
1969:43	name|CAP_LAST_U32
1969:56	operator|-
1969:58	name|i
1969:59	index|]
1969:60	argument_list|)
1969:61	expr_stmt|;
1969:62	block|}
1970:10	block|}
-:-	end_function
-:-	begin_function
1973:1	specifier|static
1973:8	name|void
1973:13	name|audit_log_fcaps
1973:28	parameter_list|(
1973:29	name|struct
1973:36	name|audit_buffer
1973:49	modifier|*
1973:50	name|ab
1973:52	parameter_list|,
1973:54	name|struct
1973:61	name|audit_names
1973:73	modifier|*
1973:74	name|name
1973:78	parameter_list|)
1974:1	block|{
1975:9	name|kernel_cap_t
1975:22	modifier|*
1975:23	name|perm
1975:28	init|=
1975:30	operator|&
1975:31	name|name
1975:35	operator|->
1975:37	name|fcap
1975:41	operator|.
1975:42	name|permitted
1975:51	decl_stmt|;
1976:9	name|kernel_cap_t
1976:22	modifier|*
1976:23	name|inh
1976:27	init|=
1976:29	operator|&
1976:30	name|name
1976:34	operator|->
1976:36	name|fcap
1976:40	operator|.
1976:41	name|inheritable
1976:52	decl_stmt|;
1977:9	name|int
1977:13	name|log
1977:17	init|=
1977:19	literal|0
1977:20	decl_stmt|;
1979:9	if|if
1979:12	condition|(
1979:13	operator|!
1979:14	name|cap_isclear
1979:25	argument_list|(
1979:26	operator|*
1979:27	name|perm
1979:31	argument_list|)
1979:32	condition|)
1979:34	block|{
1980:17	name|audit_log_cap
1980:30	argument_list|(
1980:31	name|ab
1980:33	argument_list|,
1980:35	literal|"cap_fp"
1980:43	argument_list|,
1980:45	name|perm
1980:49	argument_list|)
1980:50	expr_stmt|;
1981:17	name|log
1981:21	operator|=
1981:23	literal|1
1981:24	expr_stmt|;
1981:25	block|}
1983:9	if|if
1983:12	condition|(
1983:13	operator|!
1983:14	name|cap_isclear
1983:25	argument_list|(
1983:26	operator|*
1983:27	name|inh
1983:30	argument_list|)
1983:31	condition|)
1983:33	block|{
1984:17	name|audit_log_cap
1984:30	argument_list|(
1984:31	name|ab
1984:33	argument_list|,
1984:35	literal|"cap_fi"
1984:43	argument_list|,
1984:45	name|inh
1984:48	argument_list|)
1984:49	expr_stmt|;
1985:17	name|log
1985:21	operator|=
1985:23	literal|1
1985:24	expr_stmt|;
1985:25	block|}
1988:9	if|if
1988:12	condition|(
1988:13	name|log
1988:16	condition|)
1989:17	name|audit_log_format
1989:33	argument_list|(
1989:34	name|ab
1989:36	argument_list|,
1989:38	literal|" cap_fe=%d cap_fver=%x"
1989:62	argument_list|,
1990:34	name|name
1990:38	operator|->
1990:40	name|fcap
1990:44	operator|.
1990:45	name|fE
1990:47	argument_list|,
1990:49	name|name
1990:53	operator|->
1990:55	name|fcap_ver
1990:63	argument_list|)
1990:64	expr_stmt|;
1990:65	block|}
-:-	end_function
-:-	begin_function
1993:1	specifier|static
1993:8	specifier|inline
1993:15	name|int
1993:19	name|audit_copy_fcaps
1993:35	parameter_list|(
1993:36	name|struct
1993:43	name|audit_names
1993:55	modifier|*
1993:56	name|name
1993:60	parameter_list|,
1994:36	specifier|const
1994:42	name|struct
1994:49	name|dentry
1994:56	modifier|*
1994:57	name|dentry
1994:63	parameter_list|)
1995:1	block|{
1996:9	name|struct
1996:16	name|cpu_vfs_cap_data
1996:33	name|caps
1996:37	decl_stmt|;
1997:9	name|int
1997:13	name|rc
1997:15	decl_stmt|;
1999:9	if|if
1999:12	condition|(
1999:13	operator|!
1999:14	name|dentry
1999:20	condition|)
2000:17	return|return
2000:24	literal|0
2000:25	return|;
2002:9	name|rc
2002:12	operator|=
2002:14	name|get_vfs_caps_from_disk
2002:36	argument_list|(
2002:37	name|dentry
2002:43	argument_list|,
2002:45	operator|&
2002:46	name|caps
2002:50	argument_list|)
2002:51	expr_stmt|;
2003:9	if|if
2003:12	condition|(
2003:13	name|rc
2003:15	condition|)
2004:17	return|return
2004:24	name|rc
2004:26	return|;
2006:9	name|name
2006:13	operator|->
2006:15	name|fcap
2006:19	operator|.
2006:20	name|permitted
2006:30	operator|=
2006:32	name|caps
2006:36	operator|.
2006:37	name|permitted
2006:46	expr_stmt|;
2007:9	name|name
2007:13	operator|->
2007:15	name|fcap
2007:19	operator|.
2007:20	name|inheritable
2007:32	operator|=
2007:34	name|caps
2007:38	operator|.
2007:39	name|inheritable
2007:50	expr_stmt|;
2008:9	name|name
2008:13	operator|->
2008:15	name|fcap
2008:19	operator|.
2008:20	name|fE
2008:23	operator|=
2008:25	operator|!
2008:26	operator|!
2008:27	operator|(
2008:28	name|caps
2008:32	operator|.
2008:33	name|magic_etc
2008:43	operator|&
2008:45	name|VFS_CAP_FLAGS_EFFECTIVE
2008:68	operator|)
2008:69	expr_stmt|;
2009:9	name|name
2009:13	operator|->
2009:15	name|fcap_ver
2009:24	operator|=
2009:26	operator|(
2009:27	name|caps
2009:31	operator|.
2009:32	name|magic_etc
2009:42	operator|&
2009:44	name|VFS_CAP_REVISION_MASK
2009:65	operator|)
2009:67	operator|>>
2010:33	name|VFS_CAP_REVISION_SHIFT
2010:55	expr_stmt|;
2012:9	return|return
2012:16	literal|0
2012:17	return|;
2012:18	block|}
-:-	end_function
-:-	begin_comment
2015:1	comment|/* Copy inode data into an audit_names. */
-:-	end_comment
-:-	begin_function
2016:1	name|void
2016:6	name|audit_copy_inode
2016:22	parameter_list|(
2016:23	name|struct
2016:30	name|audit_names
2016:42	modifier|*
2016:43	name|name
2016:47	parameter_list|,
2016:49	specifier|const
2016:55	name|struct
2016:62	name|dentry
2016:69	modifier|*
2016:70	name|dentry
2016:76	parameter_list|,
2017:23	name|struct
2017:30	name|inode
2017:36	modifier|*
2017:37	name|inode
2017:42	parameter_list|)
2018:1	block|{
2019:9	name|name
2019:13	operator|->
2019:15	name|ino
2019:21	operator|=
2019:23	name|inode
2019:28	operator|->
2019:30	name|i_ino
2019:35	expr_stmt|;
2020:9	name|name
2020:13	operator|->
2020:15	name|dev
2020:21	operator|=
2020:23	name|inode
2020:28	operator|->
2020:30	name|i_sb
2020:34	operator|->
2020:36	name|s_dev
2020:41	expr_stmt|;
2021:9	name|name
2021:13	operator|->
2021:15	name|mode
2021:21	operator|=
2021:23	name|inode
2021:28	operator|->
2021:30	name|i_mode
2021:36	expr_stmt|;
2022:9	name|name
2022:13	operator|->
2022:15	name|uid
2022:21	operator|=
2022:23	name|inode
2022:28	operator|->
2022:30	name|i_uid
2022:35	expr_stmt|;
2023:9	name|name
2023:13	operator|->
2023:15	name|gid
2023:21	operator|=
2023:23	name|inode
2023:28	operator|->
2023:30	name|i_gid
2023:35	expr_stmt|;
2024:9	name|name
2024:13	operator|->
2024:15	name|rdev
2024:21	operator|=
2024:23	name|inode
2024:28	operator|->
2024:30	name|i_rdev
2024:36	expr_stmt|;
2025:9	name|security_inode_getsecid
2025:32	argument_list|(
2025:33	name|inode
2025:38	argument_list|,
2025:40	operator|&
2025:41	name|name
2025:45	operator|->
2025:47	name|osid
2025:51	argument_list|)
2025:52	expr_stmt|;
2026:9	name|audit_copy_fcaps
2026:25	argument_list|(
2026:26	name|name
2026:30	argument_list|,
2026:32	name|dentry
2026:38	argument_list|)
2026:39	expr_stmt|;
2026:40	block|}
-:-	end_function
-:-	begin_comment
2029:1	comment|/**  * audit_log_name - produce AUDIT_PATH record from struct audit_names  * @context: audit_context for the task  * @n: audit_names structure with reportable details  * @path: optional path to report instead of audit_names->name  * @record_num: record number to report when handling a list of names  * @call_panic: optional pointer to int that will be updated if secid fails  */
-:-	end_comment
-:-	begin_function
2037:1	name|void
2037:6	name|audit_log_name
2037:20	parameter_list|(
2037:21	name|struct
2037:28	name|audit_context
2037:42	modifier|*
2037:43	name|context
2037:50	parameter_list|,
2037:52	name|struct
2037:59	name|audit_names
2037:71	modifier|*
2037:72	name|n
2037:73	parameter_list|,
2038:21	specifier|const
2038:27	name|struct
2038:34	name|path
2038:39	modifier|*
2038:40	name|path
2038:44	parameter_list|,
2038:46	name|int
2038:50	name|record_num
2038:60	parameter_list|,
2038:62	name|int
2038:66	modifier|*
2038:67	name|call_panic
2038:77	parameter_list|)
2039:1	block|{
2040:9	name|struct
2040:16	name|audit_buffer
2040:29	modifier|*
2040:30	name|ab
2040:32	decl_stmt|;
2041:9	name|ab
2041:12	operator|=
2041:14	name|audit_log_start
2041:29	argument_list|(
2041:30	name|context
2041:37	argument_list|,
2041:39	name|GFP_KERNEL
2041:49	argument_list|,
2041:51	name|AUDIT_PATH
2041:61	argument_list|)
2041:62	expr_stmt|;
2042:9	if|if
2042:12	condition|(
2042:13	operator|!
2042:14	name|ab
2042:16	condition|)
2043:17	return|return;
2045:9	name|audit_log_format
2045:25	argument_list|(
2045:26	name|ab
2045:28	argument_list|,
2045:30	literal|"item=%d"
2045:39	argument_list|,
2045:41	name|record_num
2045:51	argument_list|)
2045:52	expr_stmt|;
2047:9	if|if
2047:12	condition|(
2047:13	name|path
2047:17	condition|)
2048:17	name|audit_log_d_path
2048:33	argument_list|(
2048:34	name|ab
2048:36	argument_list|,
2048:38	literal|" name="
2048:46	argument_list|,
2048:48	name|path
2048:52	argument_list|)
2048:53	expr_stmt|;
2049:9	elseif|else
2049:14	if|if
2049:17	condition|(
2049:18	name|n
2049:19	operator|->
2049:21	name|name
2049:25	condition|)
2049:27	block|{
2050:17	switch|switch
2050:24	condition|(
2050:25	name|n
2050:26	operator|->
2050:28	name|name_len
2050:36	condition|)
2050:38	block|{
2051:17	case|case
2051:22	name|AUDIT_NAME_FULL
2051:37	case|:
2052:25	comment|/* log the full path */
2053:25	name|audit_log_format
2053:41	argument_list|(
2053:42	name|ab
2053:44	argument_list|,
2053:46	literal|" name="
2053:54	argument_list|)
2053:55	expr_stmt|;
2054:25	name|audit_log_untrustedstring
2054:50	argument_list|(
2054:51	name|ab
2054:53	argument_list|,
2054:55	name|n
2054:56	operator|->
2054:58	name|name
2054:62	operator|->
2054:64	name|name
2054:68	argument_list|)
2054:69	expr_stmt|;
2055:25	break|break;
2056:17	case|case
2056:22	literal|0
2056:23	case|:
2057:25	comment|/* name was specified as a relative path and the 			 * directory component is the cwd */
2059:25	name|audit_log_d_path
2059:41	argument_list|(
2059:42	name|ab
2059:44	argument_list|,
2059:46	literal|" name="
2059:54	argument_list|,
2059:56	operator|&
2059:57	name|context
2059:64	operator|->
2059:66	name|pwd
2059:69	argument_list|)
2059:70	expr_stmt|;
2060:25	break|break;
2061:17	default|default:
2062:25	comment|/* log the name's directory component */
2063:25	name|audit_log_format
2063:41	argument_list|(
2063:42	name|ab
2063:44	argument_list|,
2063:46	literal|" name="
2063:54	argument_list|)
2063:55	expr_stmt|;
2064:25	name|audit_log_n_untrustedstring
2064:52	argument_list|(
2064:53	name|ab
2064:55	argument_list|,
2064:57	name|n
2064:58	operator|->
2064:60	name|name
2064:64	operator|->
2064:66	name|name
2064:70	argument_list|,
2065:53	name|n
2065:54	operator|->
2065:56	name|name_len
2065:64	argument_list|)
2065:65	expr_stmt|;
2065:66	block|}
2066:18	block|}
2067:11	else|else
2068:17	name|audit_log_format
2068:33	argument_list|(
2068:34	name|ab
2068:36	argument_list|,
2068:38	literal|" name=(null)"
2068:52	argument_list|)
2068:53	expr_stmt|;
2070:9	if|if
2070:12	condition|(
2070:13	name|n
2070:14	operator|->
2070:16	name|ino
2070:20	operator|!=
2070:23	name|AUDIT_INO_UNSET
2070:38	condition|)
2071:17	name|audit_log_format
2071:33	argument_list|(
2071:34	name|ab
2071:36	argument_list|,
2071:38	literal|" inode=%lu"
2072:34	literal|" dev=%02x:%02x mode=%#ho"
2073:34	literal|" ouid=%u ogid=%u rdev=%02x:%02x"
2073:67	argument_list|,
2074:34	name|n
2074:35	operator|->
2074:37	name|ino
2074:40	argument_list|,
2075:34	name|MAJOR
2075:39	argument_list|(
2075:40	name|n
2075:41	operator|->
2075:43	name|dev
2075:46	argument_list|)
2075:47	argument_list|,
2076:34	name|MINOR
2076:39	argument_list|(
2076:40	name|n
2076:41	operator|->
2076:43	name|dev
2076:46	argument_list|)
2076:47	argument_list|,
2077:34	name|n
2077:35	operator|->
2077:37	name|mode
2077:41	argument_list|,
2078:34	name|from_kuid
2078:43	argument_list|(
2078:44	operator|&
2078:45	name|init_user_ns
2078:57	argument_list|,
2078:59	name|n
2078:60	operator|->
2078:62	name|uid
2078:65	argument_list|)
2078:66	argument_list|,
2079:34	name|from_kgid
2079:43	argument_list|(
2079:44	operator|&
2079:45	name|init_user_ns
2079:57	argument_list|,
2079:59	name|n
2079:60	operator|->
2079:62	name|gid
2079:65	argument_list|)
2079:66	argument_list|,
2080:34	name|MAJOR
2080:39	argument_list|(
2080:40	name|n
2080:41	operator|->
2080:43	name|rdev
2080:47	argument_list|)
2080:48	argument_list|,
2081:34	name|MINOR
2081:39	argument_list|(
2081:40	name|n
2081:41	operator|->
2081:43	name|rdev
2081:47	argument_list|)
2081:48	argument_list|)
2081:49	expr_stmt|;
2082:9	if|if
2082:12	condition|(
2082:13	name|n
2082:14	operator|->
2082:16	name|osid
2082:21	operator|!=
2082:24	literal|0
2082:25	condition|)
2082:27	block|{
2083:17	name|char
2083:22	modifier|*
2083:23	name|ctx
2083:27	init|=
2083:29	name|NULL
2083:33	decl_stmt|;
2084:17	name|u32
2084:21	name|len
2084:24	decl_stmt|;
2085:17	if|if
2085:20	condition|(
2085:21	name|security_secid_to_secctx
2085:45	argument_list|(
2086:25	name|n
2086:26	operator|->
2086:28	name|osid
2086:32	argument_list|,
2086:34	operator|&
2086:35	name|ctx
2086:38	argument_list|,
2086:40	operator|&
2086:41	name|len
2086:44	argument_list|)
2086:45	condition|)
2086:47	block|{
2087:25	name|audit_log_format
2087:41	argument_list|(
2087:42	name|ab
2087:44	argument_list|,
2087:46	literal|" osid=%u"
2087:56	argument_list|,
2087:58	name|n
2087:59	operator|->
2087:61	name|osid
2087:65	argument_list|)
2087:66	expr_stmt|;
2088:25	if|if
2088:28	condition|(
2088:29	name|call_panic
2088:39	condition|)
2089:33	operator|*
2089:34	name|call_panic
2089:45	operator|=
2089:47	literal|2
2089:48	expr_stmt|;
2089:49	block|}
2090:19	else|else
2090:24	block|{
2091:25	name|audit_log_format
2091:41	argument_list|(
2091:42	name|ab
2091:44	argument_list|,
2091:46	literal|" obj=%s"
2091:55	argument_list|,
2091:57	name|ctx
2091:60	argument_list|)
2091:61	expr_stmt|;
2092:25	name|security_release_secctx
2092:48	argument_list|(
2092:49	name|ctx
2092:52	argument_list|,
2092:54	name|len
2092:57	argument_list|)
2092:58	expr_stmt|;
2092:59	block|}
2093:18	block|}
2096:9	comment|/* log the audit_names record type */
2097:9	name|audit_log_format
2097:25	argument_list|(
2097:26	name|ab
2097:28	argument_list|,
2097:30	literal|" nametype="
2097:42	argument_list|)
2097:43	expr_stmt|;
2098:9	switch|switch
2098:15	condition|(
2098:16	name|n
2098:17	operator|->
2098:19	name|type
2098:23	condition|)
2098:25	block|{
2099:9	case|case
2099:14	name|AUDIT_TYPE_NORMAL
2099:31	case|:
2100:17	name|audit_log_format
2100:33	argument_list|(
2100:34	name|ab
2100:36	argument_list|,
2100:38	literal|"NORMAL"
2100:46	argument_list|)
2100:47	expr_stmt|;
2101:17	break|break;
2102:9	case|case
2102:14	name|AUDIT_TYPE_PARENT
2102:31	case|:
2103:17	name|audit_log_format
2103:33	argument_list|(
2103:34	name|ab
2103:36	argument_list|,
2103:38	literal|"PARENT"
2103:46	argument_list|)
2103:47	expr_stmt|;
2104:17	break|break;
2105:9	case|case
2105:14	name|AUDIT_TYPE_CHILD_DELETE
2105:37	case|:
2106:17	name|audit_log_format
2106:33	argument_list|(
2106:34	name|ab
2106:36	argument_list|,
2106:38	literal|"DELETE"
2106:46	argument_list|)
2106:47	expr_stmt|;
2107:17	break|break;
2108:9	case|case
2108:14	name|AUDIT_TYPE_CHILD_CREATE
2108:37	case|:
2109:17	name|audit_log_format
2109:33	argument_list|(
2109:34	name|ab
2109:36	argument_list|,
2109:38	literal|"CREATE"
2109:46	argument_list|)
2109:47	expr_stmt|;
2110:17	break|break;
2111:9	default|default:
2112:17	name|audit_log_format
2112:33	argument_list|(
2112:34	name|ab
2112:36	argument_list|,
2112:38	literal|"UNKNOWN"
2112:47	argument_list|)
2112:48	expr_stmt|;
2113:17	break|break;
2113:23	block|}
2116:9	name|audit_log_fcaps
2116:24	argument_list|(
2116:25	name|ab
2116:27	argument_list|,
2116:29	name|n
2116:30	argument_list|)
2116:31	expr_stmt|;
2117:9	name|audit_log_end
2117:22	argument_list|(
2117:23	name|ab
2117:25	argument_list|)
2117:26	expr_stmt|;
2117:27	block|}
-:-	end_function
-:-	begin_function
2120:1	name|int
2120:5	name|audit_log_task_context
2120:27	parameter_list|(
2120:28	name|struct
2120:35	name|audit_buffer
2120:48	modifier|*
2120:49	name|ab
2120:51	parameter_list|)
2121:1	block|{
2122:9	name|char
2122:14	modifier|*
2122:15	name|ctx
2122:19	init|=
2122:21	name|NULL
2122:25	decl_stmt|;
2123:9	name|unsigned
2123:18	name|len
2123:21	decl_stmt|;
2124:9	name|int
2124:13	name|error
2124:18	decl_stmt|;
2125:9	name|u32
2125:13	name|sid
2125:16	decl_stmt|;
2127:9	name|security_task_getsecid
2127:31	argument_list|(
2127:32	name|current
2127:39	argument_list|,
2127:41	operator|&
2127:42	name|sid
2127:45	argument_list|)
2127:46	expr_stmt|;
2128:9	if|if
2128:12	condition|(
2128:13	operator|!
2128:14	name|sid
2128:17	condition|)
2129:17	return|return
2129:24	literal|0
2129:25	return|;
2131:9	name|error
2131:15	operator|=
2131:17	name|security_secid_to_secctx
2131:41	argument_list|(
2131:42	name|sid
2131:45	argument_list|,
2131:47	operator|&
2131:48	name|ctx
2131:51	argument_list|,
2131:53	operator|&
2131:54	name|len
2131:57	argument_list|)
2131:58	expr_stmt|;
2132:9	if|if
2132:12	condition|(
2132:13	name|error
2132:18	condition|)
2132:20	block|{
2133:17	if|if
2133:20	condition|(
2133:21	name|error
2133:27	operator|!=
2133:30	operator|-
2133:31	name|EINVAL
2133:37	condition|)
2134:25	goto|goto
2134:30	name|error_path
2134:40	goto|;
2135:17	return|return
2135:24	literal|0
2135:25	return|;
2135:26	block|}
2138:9	name|audit_log_format
2138:25	argument_list|(
2138:26	name|ab
2138:28	argument_list|,
2138:30	literal|" subj=%s"
2138:40	argument_list|,
2138:42	name|ctx
2138:45	argument_list|)
2138:46	expr_stmt|;
2139:9	name|security_release_secctx
2139:32	argument_list|(
2139:33	name|ctx
2139:36	argument_list|,
2139:38	name|len
2139:41	argument_list|)
2139:42	expr_stmt|;
2140:9	return|return
2140:16	literal|0
2140:17	return|;
2142:1	name|error_path
2142:11	label|:
2143:9	name|audit_panic
2143:20	argument_list|(
2143:21	literal|"error in audit_log_task_context"
2143:54	argument_list|)
2143:55	expr_stmt|;
2144:9	return|return
2144:16	name|error
2144:21	return|;
2144:22	block|}
-:-	end_function
-:-	begin_expr_stmt
2146:1	name|EXPORT_SYMBOL
2146:14	argument_list|(
2146:15	name|audit_log_task_context
2146:37	argument_list|)
2146:38	expr_stmt|;
-:-	end_expr_stmt
-:-	begin_function
2148:1	name|void
2148:6	name|audit_log_d_path_exe
2148:26	parameter_list|(
2148:27	name|struct
2148:34	name|audit_buffer
2148:47	modifier|*
2148:48	name|ab
2148:50	parameter_list|,
2149:27	name|struct
2149:34	name|mm_struct
2149:44	modifier|*
2149:45	name|mm
2149:47	parameter_list|)
2150:1	block|{
2151:9	name|struct
2151:16	name|file
2151:21	modifier|*
2151:22	name|exe_file
2151:30	decl_stmt|;
2153:9	if|if
2153:12	condition|(
2153:13	operator|!
2153:14	name|mm
2153:16	condition|)
2154:17	goto|goto
2154:22	name|out_null
2154:30	goto|;
2156:9	name|exe_file
2156:18	operator|=
2156:20	name|get_mm_exe_file
2156:35	argument_list|(
2156:36	name|mm
2156:38	argument_list|)
2156:39	expr_stmt|;
2157:9	if|if
2157:12	condition|(
2157:13	operator|!
2157:14	name|exe_file
2157:22	condition|)
2158:17	goto|goto
2158:22	name|out_null
2158:30	goto|;
2160:9	name|audit_log_d_path
2160:25	argument_list|(
2160:26	name|ab
2160:28	argument_list|,
2160:30	literal|" exe="
2160:37	argument_list|,
2160:39	operator|&
2160:40	name|exe_file
2160:48	operator|->
2160:50	name|f_path
2160:56	argument_list|)
2160:57	expr_stmt|;
2161:9	name|fput
2161:13	argument_list|(
2161:14	name|exe_file
2161:22	argument_list|)
2161:23	expr_stmt|;
2162:9	return|return;
2163:1	name|out_null
2163:9	label|:
2164:9	name|audit_log_format
2164:25	argument_list|(
2164:26	name|ab
2164:28	argument_list|,
2164:30	literal|" exe=(null)"
2164:43	argument_list|)
2164:44	expr_stmt|;
2164:45	block|}
-:-	end_function
-:-	begin_function
2167:1	name|struct
2167:8	name|tty_struct
2167:19	modifier|*
2167:20	name|audit_get_tty
2167:33	parameter_list|(
2167:34	name|struct
2167:41	name|task_struct
2167:53	modifier|*
2167:54	name|tsk
2167:57	parameter_list|)
2168:1	block|{
2169:9	name|struct
2169:16	name|tty_struct
2169:27	modifier|*
2169:28	name|tty
2169:32	init|=
2169:34	name|NULL
2169:38	decl_stmt|;
2170:9	name|unsigned
2170:18	name|long
2170:23	name|flags
2170:28	decl_stmt|;
2172:9	name|spin_lock_irqsave
2172:26	argument_list|(
2172:27	operator|&
2172:28	name|tsk
2172:31	operator|->
2172:33	name|sighand
2172:40	operator|->
2172:42	name|siglock
2172:49	argument_list|,
2172:51	name|flags
2172:56	argument_list|)
2172:57	expr_stmt|;
2173:9	if|if
2173:12	condition|(
2173:13	name|tsk
2173:16	operator|->
2173:18	name|signal
2173:24	condition|)
2174:17	name|tty
2174:21	operator|=
2174:23	name|tty_kref_get
2174:35	argument_list|(
2174:36	name|tsk
2174:39	operator|->
2174:41	name|signal
2174:47	operator|->
2174:49	name|tty
2174:52	argument_list|)
2174:53	expr_stmt|;
2175:9	name|spin_unlock_irqrestore
2175:31	argument_list|(
2175:32	operator|&
2175:33	name|tsk
2175:36	operator|->
2175:38	name|sighand
2175:45	operator|->
2175:47	name|siglock
2175:54	argument_list|,
2175:56	name|flags
2175:61	argument_list|)
2175:62	expr_stmt|;
2176:9	return|return
2176:16	name|tty
2176:19	return|;
2176:20	block|}
-:-	end_function
-:-	begin_function
2179:1	name|void
2179:6	name|audit_put_tty
2179:19	parameter_list|(
2179:20	name|struct
2179:27	name|tty_struct
2179:38	modifier|*
2179:39	name|tty
2179:42	parameter_list|)
2180:1	block|{
2181:9	name|tty_kref_put
2181:21	argument_list|(
2181:22	name|tty
2181:25	argument_list|)
2181:26	expr_stmt|;
2181:27	block|}
-:-	end_function
-:-	begin_function
2184:1	name|void
2184:6	name|audit_log_task_info
2184:25	parameter_list|(
2184:26	name|struct
2184:33	name|audit_buffer
2184:46	modifier|*
2184:47	name|ab
2184:49	parameter_list|,
2184:51	name|struct
2184:58	name|task_struct
2184:70	modifier|*
2184:71	name|tsk
2184:74	parameter_list|)
2185:1	block|{
2186:9	specifier|const
2186:15	name|struct
2186:22	name|cred
2186:27	modifier|*
2186:28	name|cred
2186:32	decl_stmt|;
2187:9	name|char
2187:14	name|comm
2187:18	index|[
2187:19	sizeof|sizeof
2187:25	argument_list|(
2187:26	name|tsk
2187:29	operator|->
2187:31	name|comm
2187:35	argument_list|)
2187:36	index|]
2187:37	decl_stmt|;
2188:9	name|struct
2188:16	name|tty_struct
2188:27	modifier|*
2188:28	name|tty
2188:31	decl_stmt|;
2190:9	if|if
2190:12	condition|(
2190:13	operator|!
2190:14	name|ab
2190:16	condition|)
2191:17	return|return;
2193:9	comment|/* tsk == current */
2194:9	name|cred
2194:14	operator|=
2194:16	name|current_cred
2194:28	argument_list|()
2194:30	expr_stmt|;
2195:9	name|tty
2195:13	operator|=
2195:15	name|audit_get_tty
2195:28	argument_list|(
2195:29	name|tsk
2195:32	argument_list|)
2195:33	expr_stmt|;
2196:9	name|audit_log_format
2196:25	argument_list|(
2196:26	name|ab
2196:28	argument_list|,
2197:26	literal|" ppid=%d pid=%d auid=%u uid=%u gid=%u"
2198:26	literal|" euid=%u suid=%u fsuid=%u"
2199:26	literal|" egid=%u sgid=%u fsgid=%u tty=%s ses=%u"
2199:67	argument_list|,
2200:26	name|task_ppid_nr
2200:38	argument_list|(
2200:39	name|tsk
2200:42	argument_list|)
2200:43	argument_list|,
2201:26	name|task_tgid_nr
2201:38	argument_list|(
2201:39	name|tsk
2201:42	argument_list|)
2201:43	argument_list|,
2202:26	name|from_kuid
2202:35	argument_list|(
2202:36	operator|&
2202:37	name|init_user_ns
2202:49	argument_list|,
2202:51	name|audit_get_loginuid
2202:69	argument_list|(
2202:70	name|tsk
2202:73	argument_list|)
2202:74	argument_list|)
2202:75	argument_list|,
2203:26	name|from_kuid
2203:35	argument_list|(
2203:36	operator|&
2203:37	name|init_user_ns
2203:49	argument_list|,
2203:51	name|cred
2203:55	operator|->
2203:57	name|uid
2203:60	argument_list|)
2203:61	argument_list|,
2204:26	name|from_kgid
2204:35	argument_list|(
2204:36	operator|&
2204:37	name|init_user_ns
2204:49	argument_list|,
2204:51	name|cred
2204:55	operator|->
2204:57	name|gid
2204:60	argument_list|)
2204:61	argument_list|,
2205:26	name|from_kuid
2205:35	argument_list|(
2205:36	operator|&
2205:37	name|init_user_ns
2205:49	argument_list|,
2205:51	name|cred
2205:55	operator|->
2205:57	name|euid
2205:61	argument_list|)
2205:62	argument_list|,
2206:26	name|from_kuid
2206:35	argument_list|(
2206:36	operator|&
2206:37	name|init_user_ns
2206:49	argument_list|,
2206:51	name|cred
2206:55	operator|->
2206:57	name|suid
2206:61	argument_list|)
2206:62	argument_list|,
2207:26	name|from_kuid
2207:35	argument_list|(
2207:36	operator|&
2207:37	name|init_user_ns
2207:49	argument_list|,
2207:51	name|cred
2207:55	operator|->
2207:57	name|fsuid
2207:62	argument_list|)
2207:63	argument_list|,
2208:26	name|from_kgid
2208:35	argument_list|(
2208:36	operator|&
2208:37	name|init_user_ns
2208:49	argument_list|,
2208:51	name|cred
2208:55	operator|->
2208:57	name|egid
2208:61	argument_list|)
2208:62	argument_list|,
2209:26	name|from_kgid
2209:35	argument_list|(
2209:36	operator|&
2209:37	name|init_user_ns
2209:49	argument_list|,
2209:51	name|cred
2209:55	operator|->
2209:57	name|sgid
2209:61	argument_list|)
2209:62	argument_list|,
2210:26	name|from_kgid
2210:35	argument_list|(
2210:36	operator|&
2210:37	name|init_user_ns
2210:49	argument_list|,
2210:51	name|cred
2210:55	operator|->
2210:57	name|fsgid
2210:62	argument_list|)
2210:63	argument_list|,
2211:26	name|tty
2211:29	condition|?
2211:32	name|tty_name
2211:40	argument_list|(
2211:41	name|tty
2211:44	argument_list|)
2211:46	else|:
2211:48	literal|"(none)"
2211:56	argument_list|,
2212:26	name|audit_get_sessionid
2212:45	argument_list|(
2212:46	name|tsk
2212:49	argument_list|)
2212:50	argument_list|)
2212:51	expr_stmt|;
2213:9	name|audit_put_tty
2213:22	argument_list|(
2213:23	name|tty
2213:26	argument_list|)
2213:27	expr_stmt|;
2214:9	name|audit_log_format
2214:25	argument_list|(
2214:26	name|ab
2214:28	argument_list|,
2214:30	literal|" comm="
2214:38	argument_list|)
2214:39	expr_stmt|;
2215:9	name|audit_log_untrustedstring
2215:34	argument_list|(
2215:35	name|ab
2215:37	argument_list|,
2215:39	name|get_task_comm
2215:52	argument_list|(
2215:53	name|comm
2215:57	argument_list|,
2215:59	name|tsk
2215:62	argument_list|)
2215:63	argument_list|)
2215:64	expr_stmt|;
2216:9	name|audit_log_d_path_exe
2216:29	argument_list|(
2216:30	name|ab
2216:32	argument_list|,
2216:34	name|tsk
2216:37	operator|->
2216:39	name|mm
2216:41	argument_list|)
2216:42	expr_stmt|;
2217:9	name|audit_log_task_context
2217:31	argument_list|(
2217:32	name|ab
2217:34	argument_list|)
2217:35	expr_stmt|;
2217:36	block|}
-:-	end_function
-:-	begin_expr_stmt
2219:1	name|EXPORT_SYMBOL
2219:14	argument_list|(
2219:15	name|audit_log_task_info
2219:34	argument_list|)
2219:35	expr_stmt|;
-:-	end_expr_stmt
-:-	begin_comment
2221:1	comment|/**  * audit_log_link_denied - report a link restriction denial  * @operation: specific link operation  * @link: the path that triggered the restriction  */
-:-	end_comment
-:-	begin_function
2226:1	name|void
2226:6	name|audit_log_link_denied
2226:27	parameter_list|(
2226:28	specifier|const
2226:34	name|char
2226:39	modifier|*
2226:40	name|operation
2226:49	parameter_list|,
2226:51	specifier|const
2226:57	name|struct
2226:64	name|path
2226:69	modifier|*
2226:70	name|link
2226:74	parameter_list|)
2227:1	block|{
2228:9	name|struct
2228:16	name|audit_buffer
2228:29	modifier|*
2228:30	name|ab
2228:32	decl_stmt|;
2229:9	name|struct
2229:16	name|audit_names
2229:28	modifier|*
2229:29	name|name
2229:33	decl_stmt|;
2231:9	name|name
2231:14	operator|=
2231:16	name|kzalloc
2231:23	argument_list|(
2231:24	sizeof|sizeof
2231:30	argument_list|(
2231:31	operator|*
2231:32	name|name
2231:36	argument_list|)
2231:37	argument_list|,
2231:39	name|GFP_NOFS
2231:47	argument_list|)
2231:48	expr_stmt|;
2232:9	if|if
2232:12	condition|(
2232:13	operator|!
2232:14	name|name
2232:18	condition|)
2233:17	return|return;
2235:9	comment|/* Generate AUDIT_ANOM_LINK with subject, operation, outcome. */
2236:9	name|ab
2236:12	operator|=
2236:14	name|audit_log_start
2236:29	argument_list|(
2236:30	name|current
2236:37	operator|->
2236:39	name|audit_context
2236:52	argument_list|,
2236:54	name|GFP_KERNEL
2236:64	argument_list|,
2237:30	name|AUDIT_ANOM_LINK
2237:45	argument_list|)
2237:46	expr_stmt|;
2238:9	if|if
2238:12	condition|(
2238:13	operator|!
2238:14	name|ab
2238:16	condition|)
2239:17	goto|goto
2239:22	name|out
2239:25	goto|;
2240:9	name|audit_log_format
2240:25	argument_list|(
2240:26	name|ab
2240:28	argument_list|,
2240:30	literal|"op=%s"
2240:37	argument_list|,
2240:39	name|operation
2240:48	argument_list|)
2240:49	expr_stmt|;
2241:9	name|audit_log_task_info
2241:28	argument_list|(
2241:29	name|ab
2241:31	argument_list|,
2241:33	name|current
2241:40	argument_list|)
2241:41	expr_stmt|;
2242:9	name|audit_log_format
2242:25	argument_list|(
2242:26	name|ab
2242:28	argument_list|,
2242:30	literal|" res=0"
2242:38	argument_list|)
2242:39	expr_stmt|;
2243:9	name|audit_log_end
2243:22	argument_list|(
2243:23	name|ab
2243:25	argument_list|)
2243:26	expr_stmt|;
2245:9	comment|/* Generate AUDIT_PATH record with object. */
2246:9	name|name
2246:13	operator|->
2246:15	name|type
2246:20	operator|=
2246:22	name|AUDIT_TYPE_NORMAL
2246:39	expr_stmt|;
2247:9	name|audit_copy_inode
2247:25	argument_list|(
2247:26	name|name
2247:30	argument_list|,
2247:32	name|link
2247:36	operator|->
2247:38	name|dentry
2247:44	argument_list|,
2247:46	name|d_backing_inode
2247:61	argument_list|(
2247:62	name|link
2247:66	operator|->
2247:68	name|dentry
2247:74	argument_list|)
2247:75	argument_list|)
2247:76	expr_stmt|;
2248:9	name|audit_log_name
2248:23	argument_list|(
2248:24	name|current
2248:31	operator|->
2248:33	name|audit_context
2248:46	argument_list|,
2248:48	name|name
2248:52	argument_list|,
2248:54	name|link
2248:58	argument_list|,
2248:60	literal|0
2248:61	argument_list|,
2248:63	name|NULL
2248:67	argument_list|)
2248:68	expr_stmt|;
2249:1	name|out
2249:4	label|:
2250:9	name|kfree
2250:14	argument_list|(
2250:15	name|name
2250:19	argument_list|)
2250:20	expr_stmt|;
2250:21	block|}
-:-	end_function
-:-	begin_comment
2253:1	comment|/**  * audit_log_end - end one audit record  * @ab: the audit_buffer  *  * We can not do a netlink send inside an irq context because it blocks (last  * arg, flags, is not set to MSG_DONTWAIT), so the audit buffer is placed on a  * queue and a tasklet is scheduled to remove them from the queue outside the  * irq context.  May be called in any context.  */
-:-	end_comment
-:-	begin_function
2262:1	name|void
2262:6	name|audit_log_end
2262:19	parameter_list|(
2262:20	name|struct
2262:27	name|audit_buffer
2262:40	modifier|*
2262:41	name|ab
2262:43	parameter_list|)
2263:1	block|{
2264:9	name|struct
2264:16	name|sk_buff
2264:24	modifier|*
2264:25	name|skb
2264:28	decl_stmt|;
2265:9	name|struct
2265:16	name|nlmsghdr
2265:25	modifier|*
2265:26	name|nlh
2265:29	decl_stmt|;
2267:9	if|if
2267:12	condition|(
2267:13	operator|!
2267:14	name|ab
2267:16	condition|)
2268:17	return|return;
2270:9	if|if
2270:12	condition|(
2270:13	name|audit_rate_check
2270:29	argument_list|()
2270:31	condition|)
2270:33	block|{
2271:17	name|skb
2271:21	operator|=
2271:23	name|ab
2271:25	operator|->
2271:27	name|skb
2271:30	expr_stmt|;
2272:17	name|ab
2272:19	operator|->
2272:21	name|skb
2272:25	operator|=
2272:27	name|NULL
2272:31	expr_stmt|;
2274:17	comment|/* setup the netlink header, see the comments in 		 * kauditd_send_multicast_skb() for length quirks */
2276:17	name|nlh
2276:21	operator|=
2276:23	name|nlmsg_hdr
2276:32	argument_list|(
2276:33	name|skb
2276:36	argument_list|)
2276:37	expr_stmt|;
2277:17	name|nlh
2277:20	operator|->
2277:22	name|nlmsg_len
2277:32	operator|=
2277:34	name|skb
2277:37	operator|->
2277:39	name|len
2277:43	operator|-
2277:45	name|NLMSG_HDRLEN
2277:57	expr_stmt|;
2279:17	comment|/* queue the netlink packet and poke the kauditd thread */
2280:17	name|skb_queue_tail
2280:31	argument_list|(
2280:32	operator|&
2280:33	name|audit_queue
2280:44	argument_list|,
2280:46	name|skb
2280:49	argument_list|)
2280:50	expr_stmt|;
2281:17	name|wake_up_interruptible
2281:38	argument_list|(
2281:39	operator|&
2281:40	name|kauditd_wait
2281:52	argument_list|)
2281:53	expr_stmt|;
2281:54	block|}
2282:11	else|else
2283:17	name|audit_log_lost
2283:31	argument_list|(
2283:32	literal|"rate limit exceeded"
2283:53	argument_list|)
2283:54	expr_stmt|;
2285:9	name|audit_buffer_free
2285:26	argument_list|(
2285:27	name|ab
2285:29	argument_list|)
2285:30	expr_stmt|;
2285:31	block|}
-:-	end_function
-:-	begin_comment
2288:1	comment|/**  * audit_log - Log an audit record  * @ctx: audit context  * @gfp_mask: type of allocation  * @type: audit message type  * @fmt: format string to use  * @...: variable parameters matching the format string  *  * This is a convenience function that calls audit_log_start,  * audit_log_vformat, and audit_log_end.  It may be called  * in any context.  */
-:-	end_comment
-:-	begin_function
2300:1	name|void
2300:6	name|audit_log
2300:15	parameter_list|(
2300:16	name|struct
2300:23	name|audit_context
2300:37	modifier|*
2300:38	name|ctx
2300:41	parameter_list|,
2300:43	name|gfp_t
2300:49	name|gfp_mask
2300:57	parameter_list|,
2300:59	name|int
2300:63	name|type
2300:67	parameter_list|,
2301:16	specifier|const
2301:22	name|char
2301:27	modifier|*
2301:28	name|fmt
2301:31	parameter_list|,
2301:33	modifier|...
2301:36	parameter_list|)
2302:1	block|{
2303:9	name|struct
2303:16	name|audit_buffer
2303:29	modifier|*
2303:30	name|ab
2303:32	decl_stmt|;
2304:9	name|va_list
2304:17	name|args
2304:21	decl_stmt|;
2306:9	name|ab
2306:12	operator|=
2306:14	name|audit_log_start
2306:29	argument_list|(
2306:30	name|ctx
2306:33	argument_list|,
2306:35	name|gfp_mask
2306:43	argument_list|,
2306:45	name|type
2306:49	argument_list|)
2306:50	expr_stmt|;
2307:9	if|if
2307:12	condition|(
2307:13	name|ab
2307:15	condition|)
2307:17	block|{
2308:17	name|va_start
2308:25	argument_list|(
2308:26	name|args
2308:30	argument_list|,
2308:32	name|fmt
2308:35	argument_list|)
2308:36	expr_stmt|;
2309:17	name|audit_log_vformat
2309:34	argument_list|(
2309:35	name|ab
2309:37	argument_list|,
2309:39	name|fmt
2309:42	argument_list|,
2309:44	name|args
2309:48	argument_list|)
2309:49	expr_stmt|;
2310:17	name|va_end
2310:23	argument_list|(
2310:24	name|args
2310:28	argument_list|)
2310:29	expr_stmt|;
2311:17	name|audit_log_end
2311:30	argument_list|(
2311:31	name|ab
2311:33	argument_list|)
2311:34	expr_stmt|;
2311:35	block|}
2312:10	block|}
-:-	end_function
-:-	begin_ifdef
2315:1	ifdef|#
2315:2	directive|ifdef
2315:8	name|CONFIG_SECURITY
-:-	end_ifdef
-:-	begin_comment
2316:1	comment|/**  * audit_log_secctx - Converts and logs SELinux context  * @ab: audit_buffer  * @secid: security number  *  * This is a helper function that calls security_secid_to_secctx to convert  * secid to secctx and then adds the (converted) SELinux context to the audit  * log by calling audit_log_format, thus also preventing leak of internal secid  * to userspace. If secid cannot be converted audit_panic is called.  */
-:-	end_comment
-:-	begin_function
2326:1	name|void
2326:6	name|audit_log_secctx
2326:22	parameter_list|(
2326:23	name|struct
2326:30	name|audit_buffer
2326:43	modifier|*
2326:44	name|ab
2326:46	parameter_list|,
2326:48	name|u32
2326:52	name|secid
2326:57	parameter_list|)
2327:1	block|{
2328:9	name|u32
2328:13	name|len
2328:16	decl_stmt|;
2329:9	name|char
2329:14	modifier|*
2329:15	name|secctx
2329:21	decl_stmt|;
2331:9	if|if
2331:12	condition|(
2331:13	name|security_secid_to_secctx
2331:37	argument_list|(
2331:38	name|secid
2331:43	argument_list|,
2331:45	operator|&
2331:46	name|secctx
2331:52	argument_list|,
2331:54	operator|&
2331:55	name|len
2331:58	argument_list|)
2331:59	condition|)
2331:61	block|{
2332:17	name|audit_panic
2332:28	argument_list|(
2332:29	literal|"Cannot convert secid to context"
2332:62	argument_list|)
2332:63	expr_stmt|;
2332:64	block|}
2333:11	else|else
2333:16	block|{
2334:17	name|audit_log_format
2334:33	argument_list|(
2334:34	name|ab
2334:36	argument_list|,
2334:38	literal|" obj=%s"
2334:47	argument_list|,
2334:49	name|secctx
2334:55	argument_list|)
2334:56	expr_stmt|;
2335:17	name|security_release_secctx
2335:40	argument_list|(
2335:41	name|secctx
2335:47	argument_list|,
2335:49	name|len
2335:52	argument_list|)
2335:53	expr_stmt|;
2335:54	block|}
2336:10	block|}
-:-	end_function
-:-	begin_expr_stmt
2338:1	name|EXPORT_SYMBOL
2338:14	argument_list|(
2338:15	name|audit_log_secctx
2338:31	argument_list|)
2338:32	expr_stmt|;
-:-	end_expr_stmt
-:-	begin_endif
2339:1	endif|#
2339:2	directive|endif
-:-	end_endif
-:-	begin_expr_stmt
2341:1	name|EXPORT_SYMBOL
2341:14	argument_list|(
2341:15	name|audit_log_start
2341:30	argument_list|)
2341:31	expr_stmt|;
-:-	end_expr_stmt
-:-	begin_expr_stmt
2342:1	name|EXPORT_SYMBOL
2342:14	argument_list|(
2342:15	name|audit_log_end
2342:28	argument_list|)
2342:29	expr_stmt|;
-:-	end_expr_stmt
-:-	begin_expr_stmt
2343:1	name|EXPORT_SYMBOL
2343:14	argument_list|(
2343:15	name|audit_log_format
2343:31	argument_list|)
2343:32	expr_stmt|;
-:-	end_expr_stmt
-:-	begin_expr_stmt
2344:1	name|EXPORT_SYMBOL
2344:14	argument_list|(
2344:15	name|audit_log
2344:24	argument_list|)
2344:25	expr_stmt|;
-:-	end_expr_stmt
-:-	end_unit
